<!doctype html>
<!-- From: https://bl.ocks.org/heybignick/3faf257bbbbc7743bb72310d03b86ee8 -->
<html>
  <head>
    <title>
      dewlight graph visualizer
    </title>
    <meta charset="utf-8">
    <style>

body {
  font-size: 14pt;
  line-height: 20pt;
  display: grid;
  grid-template-columns: 2fr 1fr;
  grid-template-rows: 20vh 80vh;
  grid-gap: 0pt;
  margin: 0pt;
  padding: 0pt;
}

h1 {
  font-size: larger;
  font-weight: bold;
  margin-bottom: 4pt;
}

#graphs {
  height: calc(80vh - 12pt);
  width: calc(66vw - 12pt);
  border: 1.5pt solid black;
  border-radius: 4pt;
  box-sizing: border-box;
  margin: 6pt;
  overflow: scroll;
  display: grid;
  grid-template-columns: 1fr;
  justify-items: center;
  align-items: center;
}

.graph {
  width: 500px;
  height: 500px;
  display: none; /* Hide all graphs */
}

#force_directed {
  width: 1200px; /* User can scroll to see all of it */
  height: 1200px;
}

#histogram { /* Doesn't want standard sizing */
  width: 100%;
  height: 100%;
}

#controls {
  text-align: center;
  box-sizing: border-box;
  margin: 0pt;
  padding: 6pt;
  max-height: 20vh;
  overflow: scroll;
}

.graph_controls {
  margin: 0pt;
  padding: 0pt;
  display: none;
}

.graph_label {
  margin: 0pt;
}

#fd_controls {
  display: block; /* show at start */
}

#legend {
  box-sizing: border-box;
  margin: 0pt;
  max-height: 20vh;
  padding: 6pt;
  overflow: scroll;
}

#legend_entries {
  column-count: 2;
}

.swatch {
  display: inline-block;
  margin-right: 4pt;
  width: 12pt;
  height: 12pt;
}

#sidebar {
  max-height: 80vh;
  box-sizing: border-box;
  margin: 0pt;
  padding: 0pt;
  overflow: hidden;
}

#sidebar-controls {
  height: 20%;
  box-sizing: border-box;
  margin: 0pt;
  padding: 6pt;
}

#sidebar-controls > h1:first-child {
  margin-top: 0pt;
}

#sidebar-controls > p {
  margin: 6pt 0pt 6pt 0pt;
}


#listing {
  height: 80%;
  overflow: scroll;
  box-sizing: border-box;
  margin: 0pt;
}

a:link,a:visited {
  text-decoration: none;
  color: #005599;
}

.links line, .links path {
  fill: transparent;
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: #fff;
  stroke-width: 1.5pt;
}

.selected circle {
  stroke: #000;
}

text.symbol {
  text-anchor: middle;
  dominant-baseline: central;
  font-size: 19px;
  cursor: crosshair;
  fill: black;
  stroke: white;
  stroke-width: 1.5pt;
  paint-order: stroke fill;
}

.backing {
  fill: white;
  stroke: gray;
  rx: 4px;
  ry: 4px;
}

.edge {
  cursor: crosshair;
}

.directional-edge {
  cursor: crosshair;
}

.diredge-line {
  stroke: none;
  fill: #999;
}

.diredge-bubble {
  stroke: white;
  fill: #999;
  stroke-width: 1.5pt;
}

.diredge-label {
  text-anchor: middle;
  dominant-baseline: central;
  font-size: 19px;
  fill: black;
  stroke: white;
  stroke-width: 1.5pt;
  paint-order: stroke fill;
}

rect.bar {
  cursor: crosshair;
}

rect.bar.selected {
  stroke: #000;
  stroke-width: 2pt;
}

.listing.selected a {
  text-decoration: underline;
  font-weight: bold;
}

.listing {
  display: grid;
  grid-template-columns: 1fr 8fr 2fr 2fr 2fr 2fr;
  border-bottom: 1pt dotted black;
}

.listing a:first-child {
  display: block;
  padding-left: 12pt;
  text-indent: -12pt;
}

.listing .stats {
  justify-self: start;
  align-self: center;
  font-size: smaller;
}

text {
  font-family: serif;
  font-size: 14pt;
}

#opt_spinner {
  display: none;
}

    </style>
  </head>
  <body>
    <div id="controls">
      show <select id="graph_select" onchange="select_graph(this.value)">
        <option selected="t" value="force">relationships</option>
        <option value="histogram-i">histogram (initiated)</option>
        <option value="histogram-r">histogram (received)</option>
        <option value="histogram-c">histogram (both)</option>
        <option value="ego">ego network</option>
        <option value="pair">affinity plot</option>
      </select>
      <br/>

      <div id="fd_controls" class="graph_controls">
        <h1 class="graph_label">All Relationships</h1>

        mark <select id="mark_select" onchange="set_symbols(this.value)">
          <option selected="t" value="important">important nodes</option>
          <option value="all">all nodes</option>
          <option value="none">none</option>
        </select>
        |
        hide
        <input
         type="checkbox"
         onclick="toggle_link_visibility('minor', !this.checked)">
        minor edges
        <input
         type="checkbox"
         onclick="toggle_link_visibility('passive', !this.checked)">
        passive edges
        |
        <input
         type="checkbox"
         onclick="toggle_node_filter(this.checked)">
        filter nodes
        <br/>

        <!--
        <input
         type="button"
         value="shuffle"
         onclick="shuffle()">
        |
        <input
         type="button"
         value="find optimum"
         onclick="optimize_randomly()">
        <img id="opt_spinner" src="res/loading.gif" alt="loading animation">
        |
        <input
         type="button"
         value="optimize"
         onclick="optimize_positions(SIMULATION)">
        |
        -->
        <input
         type="button"
         value="strict layout"
         onclick="impose_hive_layout(SIMULATION, undefined)">
        |
        <input
         type="button"
         value="close layout"
         onclick="impose_hive_layout(SIMULATION, SMALL_ALPHA_FACTOR)">
        |
        <input
         type="button"
         value="loose layout"
         onclick="impose_hive_layout(SIMULATION, LARGE_ALPHA_FACTOR)">
        |
        <input
         type="button"
         value="relax further"
         onclick="SIMULATION.alpha(0.25).restart()">
        <br/>
        
        <!--
        energy: <span id="energy">?</span>
        | best: <span id="best_energy">?</span>
        <br/>
        -->
      </div>

      <div id="hs_controls" class="graph_controls">
        <h1 class="graph_label">Interactions Histogram</h1>

        <input
         type="checkbox"
         checked="true"
         onclick="toggle_hist_collapse(this.checked)">
        collapse histograms
        <br/>
      </div>

      <div id="eg_controls" class="graph_controls">
        <h1 class="graph_label">Ego Network</h1>
        focus: <span id="eg_name"></span>
        |
        <input
         type="button"
         id="eg_reselect"
         onclick="set_ego(GRAPH.nodes, GRAPH.dlinks)"
         value="switch to:">
        <span id="eg_next"></span><br/>

        limit neighbors:
        <select id="eg_cutoff" onchange="set_ego(GRAPH.nodes, GRAPH.dlinks)">
          <option value="none">don't limit</option>
          <option value="3">top 3</option>
          <option value="5">top 5</option>
          <option value="10">top 10</option>
          <option value="15">top 15</option>
          <option value="20">top 20</option>
          <option value="30">top 30</option>
          <option value="aff>1">&gt;1 interaction</option>
          <option value="aff>2">&gt;2 interactions</option>
          <option value="aff>3">&gt;3 interactions</option>
          <option value="aff>5%">&gt;5% of highest</option>
          <option value="aff>10%">&gt;10% of highest</option>
          <option value="aff>25%">&gt;25% of highest</option>
          <option value="aff>50%">&gt;50% of highest</option>
          <option value="aff>75%">&gt;75% of highest</option>
          <option value="received">has link to</option>
          <option value="initiated">has link from</option>
          <option value="responded">has both links</option>
        </select>
      </div>

      <div id="af_controls" class="graph_controls">
        <h1 class="graph_label">Single Relationship</h1>
        <br/>
      </div>

    </div>
    <div id="legend">
      <h1>Colors:</h1>
      <div id="legend_entries">
      </div>
    </div>
    <div id="graphs">
      <svg id="force_directed" class="graph"></svg>
      <svg id="histogram" class="graph"></svg>
      <svg id="ego" class="graph"></svg>
      <svg id="relationship" class="graph"></svg>
    </div>
    <div id="sidebar">
      <div id="sidebar-controls">
        <h1>Listing:</h1>
        <p>
        sort by
        <select id="listing_sort" onchange="sort_listings(this.value)"/>
          <option value="default">default (by graph type)</option>
          <option value="category">category (then name)</option>
          <option value="name">name</option>
          <option value="initiated">initiated</option>
          <option value="received">received</option>
          <option value="total">total (then initiated)</option>
          <option value="neighbors">neighbors (then initiated)</option>
        </select>
        <br/>
        find:
        <input
         type="text"
         id="listing_filter"
         oninput="filter_listings(this.value)"/><input
         type="button"
         value="clear"
         onclick="this.previousSibling.value = ''; filter_listings('')"/>
        </p>
      </div>
      <div id="listing">
      </div>
    </div>
    <script src="d3/d3.v4.min.js"></script>
    <script type="text/javascript">

var FDG = d3.select("#force_directed");
var FDG_CONTROLS = d3.select("#fd_controls");
const LARGE_GRAPH_WIDTH = 1200;
const LARGE_GRAPH_HEIGHT = 1200;
const SMALL_GRAPH_WIDTH = 500;
const SMALL_GRAPH_HEIGHT = 500;

const SMALL_ALPHA_FACTOR = 12;
const LARGE_ALPHA_FACTOR = 64;

var HIST = d3.select("#histogram");
var HIST_CONTROLS = d3.select("#hs_controls");

var EGO = d3.select("#ego");
var EGO_CONTROLS = d3.select("#eg_controls");

var AFFINITY = d3.select("#affinity");
var AFFINITY_CONTROLS = d3.select("#af_controls");

// Constants that control the gap between fragments of directional edges:
const DIR_EDGE_GAP = 0.05;
const MIN_GAP_SIZE = 20;

// Font size for symbols
const SYMBOL_FONT_SIZE = 16;

//var color = d3.scaleOrdinal(d3.schemeCategory20);
var CAT_COLORS = d3.scaleOrdinal(d3.schemeCategory10);
var HCOLORS = {
  "initiated": "#f40083",
  "received": "#8300f4"
};

var SYMBOL_LISTS = {
  "Korean": "ㅁㄴㅇㅂㄷㅈㄱㅃㄸㅉㄲㅍㅌㅊㅋㅅㅎㅆㄹ",
  "Greek": "αβξδεφγθικλμνοπψρστυωχηζ",
  "English": "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
  "Arabic": "بدفتكطقذزسثشظصضغعءخحهمنرليو",
  "Devangari": "अइउऋऌएओकखगघङहचछजझञयशटठडढणरषतथदधनलसपफबभमव",
  "Japanese": "一二三四五六七八九十上中下正日大年会人本月長国出生子分東行同今高金時手見市力米自前円合立内事社者地京間田体学目後新明方部心民対主代言小思山実入回場野開万全定家北問話文動度県水安氏和政保表道相意発不党",
};
var GROUP_MAP = {
  //0: "Japanese",
  //1: "Devangari",
  0: "English",
  1: "English",
  2: "English",
  3: "English",
  4: "English",
}
var SYMBOL_MAP = {};

function zh_digit(d) {
  if (d == "0") {
    return "〇";
  } else if (d == "1") {
    return "一";
  } else if (d == "2") {
    return "二";
  } else if (d == "3") {
    return "三";
  } else if (d == "4") {
    return "四";
  } else if (d == "5") {
    return "五";
  } else if (d == "6") {
    return "六";
  } else if (d == "7") {
    return "七";
  } else if (d == "8") {
    return "八";
  } else if (d == "9") {
    return "九";
  }
}

const ZH_PLACES = [
  "",
  "十",
  "百",
  "千",
  "万"
];

function zh_numeral(digits, place) {
  // Note: doesn't work properly for just "0"
  // Note: Just aborts awkwardly above 99999
  if (place == undefined) {
    place = 0;
  }
  let d = digits[digits.length - 1];
  let rest = digits.slice(0, digits.length - 1);

  if (d == "0") { return ""; }

  if (digits.length > ZH_PLACES.length + 1) {
    console.warn("Warning: translating large number awkwardly: " + digits);
    let result = "";
    for (let digit of digits) {
      result += zh_digit(digit);
    }
    return result;
  }

  if (place >= ZH_PLACES.length) {
    console.error("Error: zh_numeral called with huge place value: " + place);
    let result = "";
    for (let digit of digits) {
      result += zh_digit(digit);
    }
    return result;
  }

  if (rest.length > 0) {
    return zh_numeral(rest, place + 1) + zh_digit(d) + ZH_PLACES[place];
  } else {
    return zh_digit(d) + ZH_PLACES[place];
  }
}

function nth_symbol(group, n) {
  let ln = GROUP_MAP[group];
  if (ln == "Numeric") {
    return "" + (n+1);
  } else if (ln == "Numeric中文") {
    return zh_numeral("" + (n + 1));
  } else {
    let sl = SYMBOL_LISTS[ln];
    let result = "";
    while (n >= sl.length) {
      let div = Math.floor(n / sl.length);
      let mod = n % sl.length;
      result = sl[mod] + result;
      n = div-1;
    }
    result = sl[n] + result;
    return result;
  }
}

function automap_groups(data) {
  let group_sizes = {};
  let by_size = Object.keys(SYMBOL_LISTS).sort(
    x, y => SYMBOL_LISTS[x].length - SYMBOL_LISTS[y].length
  );
  GROUP_MAP = {}

  // Find all the group IDs
  for (let d of data) {
    GROUP_MAP[d.group] = 0;
    if (group_sizes.hasOwnProperty(d.group)) {
      group_sizes[d.group] += 1;
    } else {
      group_sizes[d.group] = 1;
    }
  }

  // Figure out the first symbol list that's big enough for each group:
  let groups = Object.keys(GROUP_MAP);
  for (let gid of groups) {
    while (
      GROUP_MAP[gid] < by_size.length
   && SYMBOL_LISTS[by_size[GROUP_MAP[gid]]].length < group_sizes[gid]
   ) {
      GROUP_MAP[gid] += 1;
    }
    if (GROUP_MAP[gid] >= by_size.length) {
      console.warn(
        "Group of size " + group_sizes[gid] + " is too large for all available "
      + "symbol lists."
      );
      GROUP_MAP[gid] -= 1;
    }
  }

  // Build histogram of usage of each symbols list:
  usage = [];
  usage.length = by_size.length; // extend
  for (let i = 0; i < groups.length; ++i) {
    let gid = groups[i];
    let idx = GROUP_MAP[gid];
    if (usage[idx] == undefined) {
      usage[idx] = 1;
    } else {
      usage[idx] += 1;
    }
  }

  // Separate symbol assignment as much as possible:
  for (let i = 0; i < usage.length; ++i) {
    let overlap = usage[i];
    if (overlap != undefined && overlap > 1) {
      let free = 0;
      for (let j = i+1; j < usage.length; ++j) {
        if (usage[j] == undefined) {
          free += 1;
        } else {
          break;
        }
      }

      let move = Math.min(free, overlap - 1);
      for (let x = 0; x < move; ++x) {
        let reassign = undefined;
        for (gid of groups) {
          if (GROUP_MAP[gid] == i) {
            reassign = gid;
            break;
          }
        }
        if (reassign) {
          let old_list = GROUP_MAP[reassign];
          let new_list = old_list + x + 1;
          GROUP_MAP[reassign] = new_list;
          usage[old_list] -= 1;
          usage[new_list] += 1;
        }
      }
    }
  }

  // Re-express group map in terms of SYMBOL_LISTS keys:
  for (g of groups) {
    GROUP_MAP[g] = by_size[GROUP_MAP[g]];
  }

}

function set_symbols(group) {
  assign_auto(GRAPH.nodes, group);
  refresh_symbols();
}

function assign_auto(nodes, group) {
  if (group == undefined) {
    group = document.getElementById("mark_select").value;
  }
  if (group == "important") {
    assign_symbols(GRAPH.nodes, 2);
  } else if (group == "all") {
    assign_symbols(GRAPH.nodes);
  } else if (group == "none") {
    assign_symbols(GRAPH.nodes, 5);
  }
}

function assign_symbols(data, limit_groups) {
  // Assign symbols to each data ID using per-group symbol lists:
  let current = {};
  let sorted = [...data].sort(
    (a, b) => (
      d3.descending(a.initiated, b.initiated)
   || d3.descending(a.received, b.received)
   || d3.ascending(a.id, b.id)
    )
  );
  for (let d of sorted) {
    if (limit_groups && d.group < limit_groups) {
      SYMBOL_MAP[d.id] = "";
      continue;
    }
    let key = GROUP_MAP[d.group];
    let cur = current[key] || 0;
    SYMBOL_MAP[d.id] = nth_symbol(d.group, cur);
    current[key] = cur + 1;
  }
}


function symbol_for(d) {
  return SYMBOL_MAP[d.id]
}

function font_size_for(d) {
  let sym = symbol_for(d);
  return font_size_for_digits(sym, SYMBOL_FONT_SIZE, 0.7);
}

GRAPH_TYPE = "force";

function select_graph(type) {
  if (type == undefined) {
    type = GRAPH_TYPE;
  }
  GRAPH_TYPE = type;

  // Figure out target:
  if (type == "force") {
    target = "force_directed";
    controls = "fd_controls";
  } else if (type.slice(0,9) == "histogram") {
    target = "histogram";
    controls = "hs_controls";
  } else if (type == "ego") {
    target = "ego";
    controls = "eg_controls";
  } else if (type == "affinity") {
    target = "affinity";
    controls = "af_controls";
  } else {
    console.warn("Invalid graph type: '" + type + "'");
    target = "force_directed";
    controls = "fd_controls";
  }

  // Swap visibility:
  d3.selectAll(".graph").style("display", "none");
  d3.select("#" + target).style("display", "block");
  d3.selectAll(".graph_controls").style("display", "none");
  d3.select("#" + controls).style("display", "block");

  let viewport = d3.select("#graphs").node();
  let brect = viewport.getBoundingClientRect();
  let vp_width = +brect.width;
  let vp_height = +brect.height;
  // Scroll to middle if it's the force-directed graph:
  if (target == "force_directed") {
    if (LARGE_GRAPH_WIDTH > vp_width) {
      viewport.scrollLeft = LARGE_GRAPH_WIDTH/2 - vp_width/2;
    }
    if (LARGE_GRAPH_HEIGHT > vp_height) {
      viewport.scrollTop = LARGE_GRAPH_HEIGHT/2 - vp_height/2;
    }
  } else {
    if (SMALL_GRAPH_WIDTH > vp_width) {
      viewport.scrollLeft = SMALL_GRAPH_WIDTH/2 - vp_width/2;
    }
    if (SMALL_GRAPH_HEIGHT > vp_height) {
      viewport.scrollTop = SMALL_GRAPH_HEIGHT/2 - vp_height/2;
    }
  }

  // Actually (re)create the graph:
  if (type == "force") {
    set_nodes_and_links(GRAPH.nodes, GRAPH.links);
  } else if (type == "histogram-i") {
    set_bars(GRAPH.nodes, "initiated");
  } else if (type == "histogram-r") {
    set_bars(GRAPH.nodes, "received");
  } else if (type == "histogram-c") {
    set_bars(GRAPH.nodes, "combined");
  } else if (type == "ego") {
    set_ego(GRAPH.nodes, GRAPH.dlinks);
  } else if (type == "pair") {
    set_affinity(GRAPH.nodes, GRAPH.dlinks);
  } else {
    // Error messages was already generated above
    set_nodes_and_links(graph.nodes, graph.links);
  }

  // Setup legend:
  set_legend(type);
}

function set_legend(type) {
  if (type == "force" || type == "ego") {
    let in_use = [];
    for (let node of GRAPH.nodes) {
      if (in_use.indexOf(node.group) < 0) {
        in_use.push(node.group);
      }
    }

    let groups = GRAPH.groups.filter((x, i) => in_use.indexOf(i) >= 0);

    var legend = d3.select("#legend_entries");
    legend.selectAll("div").remove();
    var legend_entry = legend.selectAll("div")
      .data(groups)
      .enter().append("div");

    legend_entry.append("span")
      .text(" ")
      .classed("swatch", true)
      .style("background-color", (d, i) => CAT_COLORS(i));

    legend_entry.append("span").text(d => d);
  } else if (
    type == "histogram-i"
 || type == "histogram-r"
 || type == "histogram-c"
  ) {
    var legend = d3.select("#legend_entries");
    legend.selectAll("div").remove();
    var legend_entry = legend.selectAll("div")
      .data(Object.keys(HCOLORS))
      .enter().append("div");

    legend_entry.append("span")
      .text(" ")
      .classed("swatch", true)
      .style("background-color", (d, i) => HCOLORS[d]);

    legend_entry.append("span").text(d => d);
  } else {
    console.warn("Invalid graph type: '" + type + "'");
  }
}

// Custom bubble force to push marginal nodes out to the margins.
function forceBubble(target, radius, strength) {
  let nodes, targets, radii, strengths;

  let force = function(alpha) {
    let node, target, radius, strength;
    for (let i = 0; i < nodes.length; ++i) {
      node = nodes[i];
      target = targets[i];
      radius = radii[i];
      strength = strengths[i];
      let d = distance(node.x, node.y, target[0], target[1]);
      if (d < radius) {
        let str = Math.pow(1 - d/radius, 1/3);
        node.vx += (node.x - target[0]) * str * strength * alpha;
        node.vy += (node.y - target[1]) * str * strength * alpha;
      } // otehrwise no effect
    }
  }

  function initialize() {
    if (!nodes) { return; }

    // populate local targets
    targets = new Array(nodes.length);
    for (let i = 0; i < nodes.length; i++) {
      targets[i] = target(nodes[i], i, nodes);
    }

    // populate local radii
    radii = new Array(nodes.length);
    for (let i = 0; i < nodes.length; i++) {
      radii[i] = radius(nodes[i], i, nodes);
    }

    // populate local strengths
    strengths = new Array(nodes.length);
    for (let i = 0; i < nodes.length; i++) {
      strengths[i] = strength(nodes[i], i, nodes);
    }
  }

  force.initialize = _ => {
    nodes = _;
    initialize();
  }

  force.target = _ => {
    if (_ == null) { return target; } // no arg so return value
    
    // coerce to function
    target = typeof _ === 'function' ? _ : () => _;

    // reinitialize
    initialize();

    // allow chaining
    return force;
  };

  force.radius = _ => {
    if (_ == null) { return radius; } // no arg so return value
    
    // coerce to function
    radius = typeof _ === 'function' ? _ : () => +_;

    // reinitialize
    initialize();

    // allow chaining
    return force;
  };

  force.strength = _ => {
    if (_ == null) { return strength; } // no arg so return value
    
    // coerce to function
    strength = typeof _ === 'function' ? _ : () => +_;

    // reinitialize
    initialize();

    // allow chaining
    return force;
  };

  if (!target) { target = [0, 0]; }
  if (!radius) { radius = 80; }
  if (!strength) { strength = 0.1; }

  force.target(target);
  force.radius(radius);
  force.strength(strength);

  return force;
}

function link_distance(link) {
  //return Math.max(10, 80 - Math.sqrt(link.value));
  return 10; // until a very near distance, always pull inwards
}

function link_strength(link) {
  return (0.1 + 0.8 * (Math.log(link.value) / 6))/5;
}

link_forces = d3.forceLink()
  .id(function(d) { return d.id; })
  .distance(link_distance)
  .strength(link_strength);

separation_force = d3.forceManyBody()
  .strength(function () { return -360; })
  .distanceMax(50);

bubble_force = forceBubble()
  .target([LARGE_GRAPH_WIDTH/2, LARGE_GRAPH_HEIGHT/2])
  .radius(d => d.group == 0 ? 240 : 160)
  .strength(d => d.group >= 2 ? 0 : 0.4);

gather_force = forceBubble()
  .target([LARGE_GRAPH_WIDTH/2, LARGE_GRAPH_HEIGHT/2])
  .radius(0)
  .strength(2);

var SIMULATION = d3.forceSimulation()
  .force("link", link_forces)
  .force("charge", separation_force)
  .force("center", d3.forceCenter(LARGE_GRAPH_WIDTH/2, LARGE_GRAPH_HEIGHT/2))
  .force("bubble", bubble_force)
  .force("gather", gather_force);

function shuffle() {
  SIMULATION.nodes().forEach(function (n) {
    n.x = Math.random()*240;
    n.y = Math.random()*240;
  });
  SIMULATION.alpha(1).restart();
}

function distance(x1, y1, x2, y2) {
  return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
}

var BEST_ENERGIES = {};
var BEST_POSITIONS = {};

function compute_vel_energy(simulation, dont_track) {
  // Vel energy is simply computed by looking at the velocity of each node.
  // Even when the simulation cools, the cooling is applied *after* velocities
  // are computed, so this measure thoroughly accounts for all simulation
  // forces.
  e = 0;
  for (let node of simulation.nodes()) {
    e += Math.sqrt(node.vx * node.vx + node.vy * node.vy) / simulation.alpha();
  }
  // Track best energy
  if (!dont_track) {
    let n = simulation.nodes().length;
    if (BEST_ENERGIES[n] == undefined || e < BEST_ENERGIES[n]) {
      BEST_ENERGIES[n] = e;
      let bespan = document.getElementById("best_energy");
      if (bespan != null) {
        bespan.innerHTML = e.toExponential(3);
      }
      BEST_POSITIONS[n] = [];
      for (let node of simulation.nodes()) {
        BEST_POSITIONS[n].push([node.x, node.y]);
      }
    }
  }
  return e;
}

function compute_pull_energy(simulation, dont_track) {
  // Pull energy attempts to account for both stretched links (but it doesn't
  // penalize compressed links) and for the amount of charge force that's
  // applied across all nodes (roughly a measure of crowding).
  e = 0;
  // Add energy from stretched (but not compressed) links
  for (let link of simulation.force("link").links()) {
    let x1 = link.source.x;
    let y1 = link.source.y;
    let x2 = link.target.x;
    let y2 = link.target.y;
    let d = distance(x1, y1, x2, y2);
    let target_d = link_distance(link);
    if (d > target_d) {
      // TODO: Account for link_strength here?
      e += Math.pow(target_d - d, 2);
    }
  }
  // Add energy from charge force
  for (node of simulation.nodes()) {
    for (other of simulation.nodes()) {
      if (node === other) {
        continue;
      }
      let d = distance(node.x, node.y, other.x, other.y);
      let md = separation_force.distanceMax();
      if (d < md) {
        e += -separation_force.strength()() * (1 - d/md);
      }
    }
  }
  // Track best energy
  if (!dont_track) {
    let n = simulation.nodes().length;
    if (BEST_ENERGIES[n] == undefined || e < BEST_ENERGIES[n]) {
      BEST_ENERGIES[n] = e;
      let bespan = document.getElementById("best_energy");
      if (bespan != null) {
        bespan.innerHTML = e.toExponential(3);
      }
      BEST_POSITIONS[n] = [];
      for (let node of simulation.nodes()) {
        BEST_POSITIONS[n].push([node.x, node.y]);
      }
    }
  }
  return e;
}

function compute_stretch_energy(simulation, dont_track) {
  // Stretch energy is simply proportional to the total length of each link,
  // but weighted (linearly) according to the value of that link (total number
  // of interactions in either direction).
  e = 0;
  for (let link of simulation.force("link").links()) {
    let x1 = link.source.x;
    let y1 = link.source.y;
    let x2 = link.target.x;
    let y2 = link.target.y;
    let d = distance(x1, y1, x2, y2);
    e += d * link.value;
  }
  // Track best energy
  if (!dont_track) {
    let n = simulation.nodes().length;
    if (BEST_ENERGIES[n] == undefined || e < BEST_ENERGIES[n]) {
      BEST_ENERGIES[n] = e;
      let bespan = document.getElementById("best_energy");
      if (bespan != null) {
        bespan.innerHTML = e.toExponential(3);
      }
      BEST_POSITIONS[n] = [];
      for (let node of simulation.nodes()) {
        BEST_POSITIONS[n].push([node.x, node.y]);
      }
    }
  }
  return e;
}

// Select which energy implementation we're using:
//var compute_energy = compute_vel_energy;
//var compute_energy = compute_pull_energy;
var compute_energy = compute_stretch_energy;

function optimize_positions(simulation) {
  i = 0
  let n = simulation.nodes().length;
  if (BEST_POSITIONS[n] == undefined) {
    console.warn(
        "Can't optimize before any best positions have been observed."
    );
    return;
  }
  for (let node of simulation.nodes()) {
    node.x = BEST_POSITIONS[n][i][0];
    node.y = BEST_POSITIONS[n][i][1];
    i += 1;
  }
  simulation.alpha(1).restart();
}

function optimize_randomly() {
  // Calls mega_shuffle, but also shows a spinner while that's going on.
  // Reveal activity gif:
  let spinner = document.getElementById("opt_spinner");
  spinner.style.display = "inline";

  // Fire in two frames to allow GIF to load:
  window.requestAnimationFrame(
    function() { window.requestAnimationFrame(mega_shuffle); }
  );
}

function mega_shuffle() {
  // Shuffles 50 times and records the best configuration found, setting the
  // nodes into that configuration (approximately) at the end.

  // Run simulations:
  best = undefined;
  best_starts = undefined;
  for (let i = 0; i < 50; ++i) { // 50 trials
    SIMULATION.alpha(1); // reset alpha to 1
    SIMULATION.nodes().forEach(function (n) {
      n.x = Math.random()*20;
      n.y = Math.random()*20;
    });
    for (let j = 0; j < 3; ++j) { // tick and relax in 3 waves:
      for (let k = 0; k < 100; ++k) { // run 100 ticks
        SIMULATION.tick();
      }
      SIMULATION.alpha(1); // reset alpha to 1
    }
    for (let k = 0; k < 300; ++k) { // run another 300 ticks
      SIMULATION.tick();
    }
    compute_energy(SIMULATION, false); // compute final energy and record it
  }

  // Set node positions to best positions found:
  optimize_positions(SIMULATION);

  // Restart simulation one more time:
  SIMULATION.alpha(1).restart();

  // Hide spinner
  let spinner = document.getElementById("opt_spinner");
  spinner.style.display = "none";
}

function pos__key(pos) { return "" + pos[0] + "," + pos[1]; }
function key__pos(key) {
  let a = key.split(',');
  return [+a[0], +a[1]];
}

function simplex_neighbors(pos) {
  // All six neighbors in a simplex grid (horizontal straights; skewed right)
  return [
    [ pos[0] - 1, pos[1]],
    [ pos[0] - 1, pos[1] + 1],
    [ pos[0], pos[1] + 1],
    [ pos[0] + 1, pos[1]],
    [ pos[0] + 1, pos[1] - 1],
    [ pos[0], pos[1] - 1],
  ];
}

// Size of simplex grid:
const SIMPLEX_GRID_SIZE = 60;
// skew x and y values:
const SKX = Math.cos(Math.PI/3);
const SKY = Math.sin(Math.PI/3);

function simplex_coords(pos) {
  // Converts integer simplex coords into absolute SVG coordinates
  return [
    LARGE_GRAPH_WIDTH/2 + (pos[0] + SKX * pos[1]) * SIMPLEX_GRID_SIZE,
    LARGE_GRAPH_WIDTH/2 + SKY * pos[1] * SIMPLEX_GRID_SIZE
  ];
}

function hive_layout(nodes) {
  // A layout maps nodes <-> positions and keeps track of an edge
  let layout = {
    "positions": {},
    "occupants": {},
    "edge": new Set(),
    "edgeorder": [],
  };
  // Add 0, 0 to edge:
  layout.edge.add(pos__key([0, 0]));
  layout.edgeorder.push([0, 0]);

  // find first node; prepare to track interactions-with-placed-nodes
  let interactions = {};
  // incremental max for picking first node:
  let highest = 0;
  // next node for placement:
  let next = undefined;
  for (let node of nodes) {
    let ints = node.initiated + node.received;
    if (ints >= highest) {
      highest = ints;
      next = node;
    }
  }

  // Function for updating layout:
  function assign_pos(node, pos) {
    // Get position key:
    let k = pos__key(pos);

    // Set position of node:
    layout.positions[node.id] = pos;

    // Set occupant of position:
    if (layout.occupants[k] != undefined) {
      console.error("Double-assignment at pos: " + pos);
    }
    layout.occupants[k] = node;

    // Remove pos from edge set:
    if (!layout.edge.has(k)) {
      console.error("Assignment at non-edge: " + pos);
    }
    // And remove it from edge order:
    layout.edge.delete(k);
    let oidx = 0;
    for (; oidx < layout.edgeorder.length; ++oidx) {
      let op = layout.edgeorder[oidx];
      if (op[0] == pos[0] && op[1] == pos[1]) {
        break;
      }
    }
    if (oidx == layout.edgeorder.length) {
      console.error("Failed to find pos in edge order: " + pos);
    } else {
      layout.edgeorder.splice(oidx, 1);
    }

    // Add unoccupied neighbors to edge:
    for (let nb of simplex_neighbors(pos)) {
      let nbk = pos__key(nb);
      if (layout.occupants[nbk] == undefined && !layout.edge.has(nbk)) {
        layout.edge.add(nbk);
        layout.edgeorder.push(nb);
      }
    }

    // Update interactions of neighbors of placed node:
    for (let nbid of Object.keys(node.neighborhood)) {
      let link = lookup_link(node.id, nbid);
      if (interactions.hasOwnProperty(nbid)) {
        interactions[nbid] += link.value;
      } else {
        interactions[nbid] = link.value;
      }
    }
  }

  function pick_next_node() {
    // Picks the next node to assign by looking for the node with the most
    // interactions with nodes that have already been placed. Ties are broken
    // according to total interactions and then neighborhood size.
    let best = undefined;
    let best_any = undefined;
    let best_neighbors = undefined;
    let result = undefined;

    function better_candidate(node) {
      // Favors nodes that have more interactions-with-placed-nodes, then
      // breaks ties using total-interactions, # of neighbors, and ID values in
      // that order.
      let ints = interactions[node.id];
      let tot = node.initiated + node.received;
      let nbs = node.neighbors;
      if (best == undefined || ints > best) {
        return true;
      } else if (ints == best) {
        if (best_any == undefined || tot > best_any) {
          return true;
        } else if (tot == best_any) {
          if (best_neighbors == undefined || nbs > best_neighbors) {
          } else if (nbs == best_neighbors) {
            if (result == undefined || d3.descending(node.id, result.id)) {
              return true;
            }
          }
        }
      }
      // fall out: we're not better
      return false;
    }
    for (let nid of Object.keys(interactions)) {
      // don't pick an already-assigned node:
      if (layout.positions.hasOwnProperty(nid)) { continue; }

      // check for a new best-so-far:
      let node = lookup_node(nid);
      if (better_candidate(node)) {
        best = interactions[nid];
        best_any = node.initiated + node.received;
        best_neighbors = node.neighbors;
        result = node;
      } // else move on to next node; this one isn't a new best-so-far
    }

    if (result == undefined) {
      // iterate through all nodes, not just those touching nodes seen so far:
      for (let node of nodes) {
        // don't pick an already-assigned node:
        if (layout.positions.hasOwnProperty(node.id)) { continue; }

        // check for a new best-so-far:
        if (better_candidate(node)) {
          best = interactions[node.id];
          best_any = node.initiated + node.received;
          best_neighbors = node.neighbors;
          result = node;
        }
      }
    }

    return result; // undefined if we're out of nodes
  }

  function best_position_for(node) {
    // Picks out the position among edge positions that minimizes the weighted
    // link lengths between this node and already-positioned nodes.

    // Gather all links with positioned nodes:
    let links = [];
    for (let nid of Object.keys(layout.positions)) {
      let link = lookup_link(node.id, nid);
      if (link != undefined) {
        links.push([link, nid]);
      }
    }

    // Iterate over edge positions:
    let best_energy = undefined;
    let nearest_origin = undefined;
    let candidate = undefined;
    for (let pos of layout.edgeorder) {
      let energy = 0;
      let abs = simplex_coords(pos);
      for (let linkto of links) {
        let link = linkto[0];
        let oid = linkto[1];
        let oabs = simplex_coords(layout.positions[oid]);
        let v = [oabs[0] - abs[0], oabs[1] - abs[1]];
        let d = Math.sqrt(v[0]*v[0] + v[1]*v[1]);
        energy += d * link.value;
      }
      let origin = simplex_coords([0, 0]);
      let ov = [origin[0] - abs[0], origin[1] - abs[1]];
      let od = Math.sqrt(ov[0]*ov[0] + ov[1]*ov[1]);
      if (best_energy == undefined || energy < best_energy) {
        best_energy = energy;
        nearest_origin = od;
        candidate = pos;
      } else if (energy == best_energy) { // break ties towards origin
        if (nearest_origin == undefined || od < nearest_origin) {
          best_energy = energy;
          nearest_origin = od;
          candidate = pos;
        } // tie-break to earlier candidate by default
      }
    }
    if (candidate == undefined) {
      console.error("Failed to find best edge position:");
      console.error(node, layout);
    }

    return candidate;
  }

  // Keep assigning nodes to positions until we run out:
  do {
    target = best_position_for(next);
    assign_pos(next, target);
    next = pick_next_node();
  } while (next != undefined);

  // Return the final layout:
  return layout;
}

function impose_hive_layout(simulation, alpha_factor) {
  // Alpha factors:
  //  32 -> 150 ticks
  //  8 -> 90 ticks
  //  2 -> 30 ticks
  let nodes = simulation.nodes();
  let layout = hive_layout(nodes);
  for (let node of nodes) {
    let pos = layout.positions[node.id];
    if (pos == undefined) {
      console.warn("Hive layout left node without position:", node, layout);
    }
    let abs = simplex_coords(pos);
    node.x = abs[0];
    node.y = abs[1];
    node.vx = 0;
    node.vy = 0;
  }
  if (alpha_factor == undefined) {
    simulation.alpha(simulation.alphaMin()*2).restart();
  } else {
    simulation.alpha(simulation.alphaMin()*alpha_factor).restart();
  }
  simulation.tick();
  if (alpha_factor == undefined) {
    simulation.alpha(0);
  }
}

var GRAPH = null;
var LINKS = null;
var NODES = null;
var BARS = null;
var LISTINGS = null;
var EGO_RANKING = null;
var EGO_CURRENT = null;
var EGO_NODES = null;
var EGO_LINKS = null;
var AFFINITY_NODES = null;
var AFFINITY_LINKS = null;

// Links groups before nodes groups here to get correct overlap:
var LINKS_GROUP = FDG.append("g").attr("class", "links");
var NODES_GROUP = FDG.append("g").attr("class", "nodes");
var LABELS_GROUP = FDG.append("g").attr("class", "labels");
var BARS_GROUP = HIST.append("g").attr("class", "bars");
var EGO_LINKS_GROUP = EGO.append("g").attr("class", "links");
var EGO_NODES_GROUP = EGO.append("g").attr("class", "nodes");
var AFFINITY_LINKS_GROUP = AFFINITY.append("g").attr("class", "links");
var AFFINITY_NODES_GROUP = AFFINITY.append("g").attr("class", "nodes");

// List of nodes in sidebar:
var LISTING = d3.select("#listing")

function link_class(link) {
  if (link.source.group >= 2 && link.target.group >= 2) {
    return "major";
  } else if (link.source.group == 0 || link.target.group == 0) {
    return "passive";
  } else {
    return "minor";
  }
}

function refresh_symbols() {
  // Updates symbols using the current symbol assignment to update the
  // necessary SVG elements.

  // Force-directed graph
  if (NODES) {
    NODES.selectAll("text.symbol").remove();
    NODES.append("text")
      .text(d => symbol_for(d))
      .style("font-size", d => font_size_for(d))
      .classed("symbol", true)
      .attr('x', 0)
      .attr('y', 0)
      .on("mouseover", hoverstarted)
      .on("mouseout", hoverended)
      .on("click", d => toggle_select(d, !d.__selected__))
      .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));
  }

  // Ego graph
  if (EGO_NODES) {
    EGO_NODES.selectAll("text.symbol").remove();
    EGO_NODES.append("text")
      .text(d => symbol_for(d))
      .style("font-size", d => font_size_for(d))
      .classed("symbol", true)
      .attr('x', 0)
      .attr('y', 0)
      .on("mouseover", hoverstarted)
      .on("mouseout", hoverended)
      .on("click", d => toggle_select(d, !d.__selected__))
  }

  // Sidebar
  LISTINGS.select("span.symbol")
    .text(function (d) { return symbol_for(d); });
}

function set_nodes_and_links(nodes, links) {
  // Assign symbols:
  assign_auto(nodes);

  // Note: order that we add things here doesn't matter because they all go
  // into groups that are already ordered correctly for stacking.
  // Nodes:
  NODES_GROUP.selectAll("g").remove();
  NODES = NODES_GROUP.selectAll("g")
    .data(nodes)
    .enter().append("g");

  NODES.each(function(d) { d.__node__ = this; });

  var node_titles = NODES.append("title")
    .text(function(d) {
      return (
        d.id
      + "\nInitiated: " + d.initiated
      + "\nReceived: " + d.received
      + "\nNeighbors: " + d.neighbors
      );
    });

  // Add circles last so they sit on top of edges:  
  var circles = NODES.append("circle")
    .attr("fill", function(d) { return CAT_COLORS(d.group); })
    .attr("r", 11)
    .style("cursor", "crosshair")
    .on("mouseover", hoverstarted)
    .on("mouseout", hoverended)
    .on("click", d => toggle_select(d, !d.__selected__))
    .call(d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended));

  LINKS_GROUP.selectAll("g").remove()
  LINKS = LINKS_GROUP.selectAll("g")
    .data(links)
    .enter().append("g");

  LINKS.each(function(d) { d.__edge__ = this; });

  // Edges go first so that they end up at the back:
  var edges = LINKS.append("line")
    .classed("edge", true)
    .attr(
      "stroke-width",
      function(d) { return d.value > 1 ? 0.5 + Math.sqrt(d.value) : 1; }
    );

  // After simulation links have been added
  LINKS.attr(
    "class",
    function(d) {
      let cls = link_class(d);
      return "link " + cls;
    }
  )
  .style(
    'visibility',
    function (d) {
      let cls = link_class(d);
      ["hidden", "visible"][+SHOW_LINKS[cls]];
    }
  );

  var edge_titles = LINKS.append("title")
    .text(
      function(d) {
        return d.source.id + "—" + d.value + "—" + d.target.id;
      }
    );

  // Labels last so they're over everything else:
  FDG.selectAll("g.label").remove();
  var labels = FDG.selectAll("g.label")
    .data(nodes)
    .enter().append("g");

  labels
    .classed("label", true)
    .attr(
      'transform',
      "translate("
    + (LARGE_GRAPH_WIDTH/4 + 12) + ","
    + (LARGE_GRAPH_HEIGHT/4 + 24) + ")"
    )
    .style('visibility', "hidden")
    .each(function(d) { d.__label__ = this; });

  // reposition labels if/when the graph is scrolled
  d3.select("#graphs")
    .on("scroll", function () {
      let st = this.scrollTop;
      let sl = this.scrollLeft;
      let pos = "translate(" + (sl + 12) + "," + (st + 24) + ")";
      labels.attr('transform', pos);
    });

  var ltext = labels.append("text")
    .classed("label-text", true)
    .attr('z', 20)
    .text(function(d) {
      return d.id;
    })
    .each( // can't use d3 to create backing because order matters
      function () {
        let backing = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "rect"
        );
        backing.classList.add("backing");
        let mybb = this.getBBox();
        backing.setAttribute('x', mybb.x - 4);
        backing.setAttribute('y', mybb.y - 2);
        backing.setAttribute('width', mybb.width + 8);
        backing.setAttribute('height', mybb.height + 4);
        this.parentNode.insertBefore(backing, this);
      }
    );

  // Node divs on the sidebar:
  LISTING.selectAll("div").remove()
  LISTINGS = LISTING.selectAll("div")
    .data(nodes)
    .enter().append("div")
  LISTINGS
    .classed("listing", true)
    .classed("selected", d => SELECTED_NODES.has(d.id))
    .each(function(d) { d.__char__ = this; });
  sort_listings(document.getElementById("listing_sort").value);

  refresh_symbols();

  function ticked() {
    edges
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    NODES
        .attr("transform", function(d) {
          return "translate(" + d.x + "," + d.y + ")";
        })

    let e = compute_energy(
        SIMULATION,
        SIMULATION.alpha() > SIMULATION.alphaMin()
    );

    let espan = document.getElementById("energy");
    if (espan != null) {
      espan.innerHTML = e.toExponential(3);
    }
  }

  SIMULATION
      .nodes(nodes)
      .on("tick", ticked);

  // Note: this is where link source/target IDs are replaced with source/target
  // node refs!
  SIMULATION.force("link")
      .links(links);

  SIMULATION.force("bubble").initialize(nodes);

  // the hive layout takes care of this, but otherwise it would be needed
  //SIMULATION.alpha(1).restart();

  // Impose loose hive layout:
  impose_hive_layout(SIMULATION, LARGE_ALPHA_FACTOR);
}

BAR_TYPE = "initiated";

function font_size_for_digits(value, base_size, scale_factor) {
  if (scale_factor == undefined) {
    scale_factor = 0.92;
  }
  let llen = ("" + value).length;
  result = base_size * Math.pow(scale_factor, Math.max(llen-1, 0));
  if (result < 4) {
    console.warn(
      "Value '" + value + "' with base font size " + base_size + " resulted in "
    + "very small text (" + result + "pt)."
    );
  } else if (result < 2) {
    console.error(
      "Value '" + value + "' with base font size " + base_size + " resulted in "
    + "illegible text (" + result + "pt)."
    );
  }
  return result + "px";
}

function set_bars(data, plot) {
  // Assign symbols:
  assign_auto(data);

  if (plot == undefined) {
    plot = BAR_TYPE;
  }
  BAR_TYPE = plot;

  // Figure out size of histogram:
  let hist_width = +HIST.node().parentNode.getBoundingClientRect().width;
  let hist_height = +HIST.node().parentNode.getBoundingClientRect().height;

  // Compute selected bars:
  let sel = {
    "initiated": new Set(),
    "received": new Set()
  };
  let sel_data = data.filter(d => SELECTED_NODES.has(d.id));
  for (let d of sel_data) {
    sel.initiated.add(d.initiated);
    sel.received.add(d.received);
  }

  // Build histograms:
  let hist = [];

  for (let d of data) {
    if (plot == "combined") {
      let i = d['initiated'];
      let r = d['received'];
      if (hist[i]) {
        hist[i][0] += 1;
      } else {
        hist[i] = [1, 0];
      }
      if (hist[r]) {
        hist[r][1] += 1;
      } else {
        hist[r] = [0, 1];
      }
    } else {
      let val = d[plot];
      if (hist[val]) {
        hist[val] += 1;
      } else {
        hist[val] = 1;
      }
    }
  }

  let hbars = [];
  for (let i = 0; i < hist.length; ++i) {
    if (hist[i] == undefined && COLLAPSE_HISTOGRAMS) {
      continue; // don't add a bar
    }
    if (plot == "combined") {
      hbars.push([i, hist[i] || [0, 0]]);
    } else {
      hbars.push([i, hist[i] || 0]);
    }
  }
  let max_val;
  if (plot == "combined") {
    max_val = Math.max(...hbars.map(x => Math.max(...x[1])));
  } else {
    max_val = Math.max(...hbars.map(x => x[1]));
  }

  let bar_width = Math.max(
    24,
    (hist_width - 30) / Math.min(20, hbars.length)
  );

  if (plot == "combined") {
    function bar_height(d) {
      return (d/max_val) * (hist_height - 45)/2;
    }
    function bar_top(d) {
      return (hist_height - 30)/2 - bar_height(d[0]);
    }
    function bar_bot(d) {
      return (hist_height - 30)/2 + 30 + bar_height(d[1]);
    }
  } else {
    function bar_height(d) {
      return (d/max_val) * (hist_height - 45);
    }
    function bar_top(d) {
      return hist_height - 30 - bar_height(d);
    }
  }

  BARS_GROUP.selectAll("rect").remove();
  BARS = BARS_GROUP.selectAll("rect.bar.above")
    .data(hbars)
    .enter().append("rect");

  BARS
    .classed("bar", true)
    .classed("above", true)
    .attr('x', (d, i) => 15 + i*bar_width + bar_width/20)
    .attr('y', d => bar_top(d[1]))
    .attr('width', bar_width - bar_width/10)
    .on(
      "click",
      function (d) {
        let chars = LISTINGS.data();
        let rect_node = this;
        let was_selected = rect_node.classList.contains("selected");
        for (let ch of chars) {
          if (
            (plot == "combined" && ch.initiated == d[0])
         || ch[plot] == d[0]
          ) {
            toggle_select(ch, !was_selected);
          }
        }
      }
    );

  if (plot == "combined") {
    BARS
      .classed("initiated", true)
      .classed("selected", d => sel.initiated.has(d[0]))
      .attr('fill', HCOLORS['initiated'])
      .attr('height', d => bar_height(d[1][0]));
  } else {
    BARS
      .classed(plot, true)
      .classed("selected", d => sel[plot].has(d[0]))
      .attr('fill', HCOLORS[plot])
      .attr('height', d => bar_height(d[1]));
  }

  BARS_GROUP.selectAll("text").remove();

  let names = [];
  let nd = [...data];
  nd.sort((a, b) => d3.ascending(a.id, b.id));
  if (plot == "combined") {
    nd.forEach(
      function(d) {
        if (names[d.initiated]) {
          names[d.initiated] += "\n" + d.id;
        } else {
          names[d.initiated] = d.id;
        }
      }
    )
  } else {
    nd.forEach(
      function(d) {
        if (names[d[plot]]) {
          names[d[plot]] += "\n" + d.id;
        } else {
          names[d[plot]] = d.id;
        }
      }
    )
  }

  let bar_titles = BARS.append("title")
    .text(d => names[d[0]]);

  let ticks = BARS_GROUP.selectAll("text.tick")
    .data(hbars)
    .enter().append("text")
      .classed("tick", true)
      .text(d => d[0])
      .style("text-anchor", "middle")
      .style("font-size", (d, i) => font_size_for_digits(d[0], 12))
      .attr('x', (d, i) => 15 + i*bar_width + bar_width/2);

  if (plot == "combined") {
    ticks
      .attr('y', (hist_height/2))
      .style("dominant-baseline", "central");
  } else {
    ticks
      .attr('y', hist_height - 20)
      .style("dominant-baseline", "hanging");
  }

  let labels = BARS_GROUP.selectAll("text.label.above")
    .data(hbars)
    .enter().append("text")
      .classed("label", true)
      .classed("above", true)
      .style("text-anchor", "middle")
      .style("font-size", (d, i) => font_size_for_digits(d[0], 10))
      .attr('x', (d, i) => 15 + i*bar_width + bar_width/2);

  let lp = 4;
  let ll = 18;

  if (plot == "combined") {
    labels
      .classed("initiated", true)
      .text(d => d[1][0])
      .style("visibility", d => d[1][0] > 0 ? "visible" : "hidden")
      .attr('fill', d => bar_height(d[1][0]) > ll ? 'white': 'black')
      .attr(
        'y',
        d => bar_height(d[1][0]) > ll ? bar_top(d[1]) + lp: bar_top(d[1]) - lp
      )
      .style(
        "dominant-baseline",
        d => bar_height(d[1][0]) > ll ? "hanging": "baseline"
      );
  } else {
    labels
      .classed(plot, true)
      .text(d => d[1])
      .style("visibility", d => d[1] > 0 ? "visible" : "hidden")
      .attr('fill', d => bar_height(d[1]) > ll ? 'white': 'black')
      .attr(
        'y',
        d => bar_height(d[1]) > ll ? bar_top(d[1]) + lp: bar_top(d[1]) - lp
      )
      .style(
        "dominant-baseline",
        d => bar_height(d[1]) > ll ? "hanging": "baseline"
      );
  }

  // Extra bars going downwards:
  if (plot == "combined") {
    BARS = BARS_GROUP.selectAll("rect.bar.below")
      .data(hbars)
      .enter().append("rect")
      .classed("bar", true)
      .classed("below", true)
      .classed("received", true)
      .classed("selected", d => sel.received.has(d[0]))
      .attr('x', (d, i) => 15 + i*bar_width + bar_width/20)
      .attr('width', bar_width - bar_width/10)
      .attr('height', d => bar_height(d[1][1]))
      .attr('y', (hist_height - 30)/2 + 30)
      .attr('fill', HCOLORS['received'])
      .on(
        "click",
        function (d) {
          let chars = LISTINGS.data();
          let rect_node = this;
          let was_selected = rect_node.classList.contains("selected");
          for (let ch of chars) {
            if (ch.received == d[0]) {
              toggle_select(ch, !was_selected);
            }
          }
        }
      );

    let bot_names = [];
    let nd = [...data];
    nd.sort((a, b) => d3.ascending(a.id, b.id));
    nd.forEach(
      function(d) {
        if (bot_names[d.received]) {
          bot_names[d.received] += "\n" + d.id;
        } else {
          bot_names[d.received] = d.id;
        }
      }
    )

    let bot_titles = BARS.append("title")
      .text(d => bot_names[d[0]]);

    let bot_labels = BARS_GROUP.selectAll("text.label.below")
      .data(hbars)
      .enter().append("text")
        .classed("label", true)
        .classed("below", true)
        .text(d => d[1][1])
        .style("visibility", d => d[1][1] > 0 ? "visible" : "hidden")
        .style("text-anchor", "middle")
        .style("font-size", (d, i) => font_size_for_digits(d[0], 10))
        .attr('x', (d, i) => 15 + i*bar_width + bar_width/2)
        .attr('fill', d => bar_height(d[1]) > ll ? 'white': 'black')
        .attr(
          'y',
          d => bar_height(d[1][1]) > ll ? bar_bot(d[1]) - lp: bar_bot(d[1]) + lp
        )
        .style(
          "dominant-baseline",
          d => bar_height(d[1][1]) > ll ? "baseline": "hanging"
        );
  }

  // overflow-x on #graphs + this = scroll
  d3.select("#histogram").style('width', (30 + bar_width * hbars.length)+"px");
}

function lookup_node(id) {
  // Looks up a node by its ID value.
  return GRAPH.node_table[id];
}

function lookup_link(from_id, to_id) {
  // Looks up the canonical (undirected) edge between the nodes with the given
  // IDs, or returns undefined if there isn't one.
  if (!GRAPH.link_table.hasOwnProperty(from_id)) {
    return undefined; // no edges at all from that node
  }
  return GRAPH.link_table[from_id][to_id]; // okay if this is undefined
}

function lookup_dlink(from_id, to_id) {
  // Looks up the directed edge between the nodes with the given IDs, or returns
  // undefined if there isn't one.
  if (!GRAPH.dlink_table.hasOwnProperty(from_id)) {
    return undefined; // no outgoing edges from that node
  }
  return GRAPH.dlink_table[from_id][to_id]; // okay if this is undefined
}

function ensure_single_selected() {
  // Ensures that exactly one node is selected. Selects the node with the most
  // initiated + received interactions if none is already selected, or the
  // most-recently-selected node if multiple are selected.
  if (SELECTED_NODES.size == 0) {
    let sorted_nodes = [...GRAPH.nodes].sort(
      function(a, b) {
        return (
          d3.descending(a.initiated + a.received, b.initiated + b.received)
       || d3.descending(a.initiated, b.initiated)
       || d3.descending(a.received, b.received)
       || d3.ascending(a.id, b.id)
        );
      }
    );
    toggle_select(sorted_nodes[0], true);
  } else if (SELECTED_NODES.size > 1) {
    // deselect all but the most-recently-selected node
    let deselect = [];
    for (let i = 0; i < SELECTION_ORDER.length - 1; ++i) {
      deselect.push(SELECTION_ORDER[i]);
    }
    for (let i = 0; i < deselect.length; ++i) {
      toggle_select(lookup_node(deselect[i]), false);
    }
  }
}

function ensure_at_least_two_selected() {
  // Works like ensure_pair_selected, but does not deselect nodes if more than
  // two are selected.
  if (SELECTED_NODES.size < 2) {
    ensure_single_selected();
    let from_node = lookup_node(SELECTION_ORDER[0]);
    let links_touching = [];
    for (let link of GRAPH.links) {
      if (link.source === from_node || link.target === from_node) {
        links_touching.push(link);
      }
    }
    let best = 0;
    let chosen = undefined;
    for (let other of GRAPH.nodes) {
      let value = 0;
      for (let link of links_touching) {
        if ( // TODO: This could be more efficient (we know who comes first)
          (link.source == from_node && link.target === other)
       || (link.target == from_node && link.source === other)
        ) {
          value += link.value;
        }
      }
      if (value > best) {
        best = value;
        chosen = other;
      }
    }
    if (chosen == undefined) {
      chosen = GRAPH.nodes[0];
    }
    // Select that node
    toggle_select(chosen, true);

  } // don't do anything here...
}

function ensure_pair_selected() {
  // Ensures that exactly two nodes are selected. If more than two nodes are
  // selected, it deselects all but the most recent pair. Otherwise, it first
  // ensures that one node is selected (see ensure_single_selected) and then
  // adds the node that has the most interactions with that node (or just the
  // first node in the graph if that node has no interactions at all).

  if (SELECTED_NODES.size < 2) {
    ensure_at_least_two_selected();
  } else if (SELECTED_NODES.size > 2) { // too many selected
    // deselect all but the two most-recently-selected nodes
    let deselect = [];
    for (let i = 0; i < SELECTION_ORDER.length - 2; ++i) {
      deselect.push(SELECTION_ORDER[i]);
    }
    for (let i = 0; i < deselect.length; ++i) {
      toggle_select(lookup_node(deselect[i]), false);
    }
  }
}

function node_affinity(from, to) {
  // Returns an affinity value between the two nodes (the number of times
  // either entity spoke to the other). Returns zero for entities that have
  // never spoken to each other, and when the same node is both from and to,
  // unless that entity has talked to itself.
  // TODO: make this more efficient?
  let link = lookup_link(from.id, to.id);
  if (link) {
    return link.value;
  } else {
    return 0;
  }
}

function ego_layout_position(focus, node, visible_nodes) {
  // Returns an [x, y] array specifying the position for the given node in an
  // ego layout that's focused on the given focus node. Returns undefined for
  // nodes that aren't directly connected to the given focus node. Arranges
  // nodes in a spiral, starting with the most-interacting node on the right
  // and continuing clockwise, moving outwards to show relative strength of
  // connection.
  let s_width = +EGO.node().getBoundingClientRect().width;
  let s_height = +EGO.node().getBoundingClientRect().height;
  let dim = Math.max(1, Math.min(s_width, s_height));
  if (node === focus) {
    return [s_width / 2, s_height / 2];
  } else if (node.__ego_rank__ != undefined) {
    let theta = 0;
    let incr = 2*Math.PI / (visible_nodes.length-1);
    let aff = node.__ego_rank__.affinity;
    let max = EGO_RANKING[0].affinity;
    let r = (dim*.47) * (1 - (aff / max) / 2);
    return [
      s_width / 2 + Math.cos(theta + incr * node.__ego_rank__.rank) * r,
      s_height / 2 + Math.sin(theta + incr * node.__ego_rank__.rank) * r
    ];
  } else {
    // This node isn't ranked:
    return undefined;
  }
}

function dir_edge_points(dlink, get_elem) {
  // Computes the edge points for a directional edge, given a function for
  // extracting a d3 element from a node (the provided directional link is
  // presumed to have node references as its source and target). The result
  // includes properties that specify two positions:
  //
  //  xs, ys: the start position
  //  xe, ye: the end position
  let src_elem = get_elem(dlink.source);
  let trg_elem = get_elem(dlink.target);
  let src_transform = src_elem.transform.baseVal.consolidate().matrix;
  let trg_transform = trg_elem.transform.baseVal.consolidate().matrix;
  let src_pos = [src_transform.e, src_transform.f];
  let trg_pos = [trg_transform.e, trg_transform.f];
  if (src_elem === trg_elem) {
    return {
      "xs": src_pos[0], "ys": src_pos[1],
      "xe": src_pos[0], "ye": src_pos[1],
    };
  } else {
    let vector = [trg_pos[0] - src_pos[0], trg_pos[1] - src_pos[1]];
    let mag = Math.sqrt(vector[0]*vector[0] + vector[1]*vector[1]);
    let ulink = lookup_link(dlink.source.id, dlink.target.id);
    let fr = dlink.value / ulink.value;
    let gap = Math.max(MIN_GAP_SIZE/mag, 0.05); // don't let gaps shrink too far
    let sc = (0.15 + 0.7 * fr) * (1 - gap); // scale
    if (fr == 1) { // no opposite member; back off a bit
      sc = 0.3;
    }
    return {
      "xs": src_pos[0], "ys": src_pos[1],
      "xe": src_pos[0] + sc * vector[0], "ye": src_pos[1] + sc * vector[1],
    };
  }
}

function filter_ego_node(node, cutoff) {
  if (node.id == EGO_CURRENT) {
    return true; // focus node always passes!
  }

  if (node.__ego_rank__ == undefined) {
    return false; // not even connected to our focus node
  }

  let in_link = lookup_dlink(node.id, EGO_CURRENT);
  let out_link = lookup_dlink(EGO_CURRENT, node.id);

  if (cutoff == "none") {
    return true;
  } else if (!isNaN(+cutoff)) {
    return node.__ego_rank__.rank < +cutoff;
  } else if (cutoff.slice(0, 4) == "aff>") {
    let threshold;
    if (cutoff.slice(cutoff.length - 1, cutoff.length) == "%") {
      let max = EGO_RANKING[0].affinity;
      let pct = +cutoff.slice(4, cutoff.length - 1);
      threshold = Math.floor(max * pct/100);
    } else {
      threshold = +cutoff.slice(4);
    }
    if (isNaN(threshold)) {
      console.error(
        "Invalid computed threshold value! Cutoff is: '" + cutoff + "'."
      );
      threshold = 1;
    }
    return node.__ego_rank__.affinity > threshold;
  } else if (cutoff == "received") {
    return out_link != undefined;
  } else if (cutoff == "initiated") {
    return in_link != undefined;
  } else if (cutoff == "responded") {
    return (in_link != undefined && out_link != undefined);
  }
}

function set_ego(nodes, dlinks) {
  // Sets up the ego graph, resetting the selection to be a single node (the
  // first one that was selected if several are now, or the most-interacting
  // node if no node is selected).
  ensure_single_selected();

  // Look up size of svg element:
  var s_width = +EGO.node().getBoundingClientRect().width;
  var s_height = +EGO.node().getBoundingClientRect().height;

  // Assign symbols:
  assign_auto(nodes);

  // Get selected node:
  let focus_node = lookup_node(SELECTION_ORDER[0]);
  EGO_CURRENT = focus_node.id;

  // Set controls:
  d3.select("#eg_name").text(focus_node.id);
  d3.select("#eg_reselect").node().disabled = true;
  d3.select("#eg_next").text(focus_node.id);

  // Compute affinities and rank nodes:
  EGO_RANKING = [];
  for (let node of nodes) {
    delete node.__ego_rank__;
    if (node != focus_node) {
      let aff = node_affinity(focus_node, node);
      if (aff > 0) {
        let olink = lookup_dlink(focus_node.id, node.id);
        let ilink = lookup_dlink(node.id, focus_node.id);
        let rank = {
          "affinity": aff,
          "initiated": olink != undefined ? olink.value : 0,
          "received": ilink != undefined ? ilink.value : 0,
          "node": node,
          "rank": EGO_RANKING.length
        };
        EGO_RANKING.push(rank);
        node.__ego_rank__ = rank;
      }
    }
  }

  // Sort in descending order by affinity scores:
  EGO_RANKING = EGO_RANKING.sort(
    (a, b) => (
      d3.descending(a.affinity, b.affinity)
   || d3.descending(
        (a.initiated > 0) + (a.received > 0),
        (b.initiated > 0) + (b.received > 0)
      )
   || d3.descending(a.initiated, b.initiated)
   || d3.ascending(a.node.id, b.node.id)
    )
  );

  let r = 0;
  for (let rank of EGO_RANKING) {
    rank.rank = r;
    r += 1;
  }

  // Check filters:
  let cutoff = document.getElementById("eg_cutoff").value;

  // Filter nodes and edges:
  let visible_nodes = nodes.filter(n => filter_ego_node(n, cutoff));
  let vnset = new Set();
  for (let node of visible_nodes) { vnset.add(node.id); }
  let relevant_edges = dlinks.filter(
    function (l) {
      if (l.source === focus_node) {
        return vnset.has(l.target.id);
      } else if (l.target === focus_node) {
        return vnset.has(l.source.id);
      } else {
        return false;
      }
    }
  );

  // Assign node positions:
  for (let node of visible_nodes) {
    node.__ego_pos__ = ego_layout_position(focus_node, node, visible_nodes);
  }

  // Set up nodes:
  EGO_NODES_GROUP.selectAll("g").remove();
  EGO_NODES = EGO_NODES_GROUP.selectAll("g")
    .data(visible_nodes)
    .enter().append("g");

  EGO_NODES.each(function(d) { d.__ego_node__ = this; });

  EGO_NODES
    .attr(
      "transform",
      function(d) {
        return "translate(" + d.__ego_pos__[0] + "," + d.__ego_pos__[1] + ")";
      }
    )
    .classed("selected", d => SELECTED_NODES.has(d.id));

  var circles = EGO_NODES.append("circle")
    .attr("fill", function(d) { return CAT_COLORS(d.group); })
    .attr("r", 11)
    .style("cursor", "crosshair")
    .on("mouseover", hoverstarted)
    .on("mouseout", hoverended)
    .on("click", d => toggle_select(d, !d.__selected__))
    .call(d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended));

  // EGO_NODES.append("text").text(d => node_affinity(focus_node, d));

  // Links
  EGO_LINKS_GROUP.selectAll("g").remove()
  EGO_LINKS = EGO_LINKS_GROUP.selectAll("g")
    .data(relevant_edges)
    .enter().append("g");

  EGO_LINKS.each(function(d) { d.__ego_edge__ = this; });

  var edges = EGO_LINKS.append("g")
    .classed("directional-edge", true)

  var edge_lines = edges.append("path")
    .classed("diredge-line", true)
    .attr(
      "stroke-width",
      function(d) { return d.value > 1 ? 0.5 + Math.sqrt(d.value) : 1; }
    );

  edge_lines
    .attr(
      "d",
      function(d) {
        let points = dir_edge_points(d, x => x.__ego_node__);
        return (
          "M " + points.xs + " " + points.ys
        + " L " + points.xe + " " + points.ye
        );
      }
    );

  /*
  var edge_bubbles = edges.append("circle")
    .classed("diredge-bubble", true)
    .attr("r", 9)
    .attr("cx", d => dir_edge_points(d, x => x.__ego_node__).xe)
    .attr("cy", d => dir_edge_points(d, x => x.__ego_node__).ye);
  */

  var edge_labels = edges.append("text")
    .classed("diredge-label", true)
    .attr("x", d => dir_edge_points(d, x => x.__ego_node__).xe)
    .attr("y", d => dir_edge_points(d, x => x.__ego_node__).ye)
    .style("font-size", d => font_size_for_digits(d.value, 15, 0.85))
    .text(d => d.value);

  // node labels
  EGO.selectAll("g.label").remove();
  var labels = EGO.selectAll("g.label")
    .data(visible_nodes)
    .enter().append("g");

  labels
    .classed("label", true)
    .attr('transform', "translate(12, 24)")
    .style('visibility', "hidden")
    .each(function(d) { d.__ego_label__ = this; });

  // reposition labels if/when the graph is scrolled
  d3.select("#graphs")
    .on("scroll", function () {
      let st = this.scrollTop;
      let sl = this.scrollLeft;
      let pos = "translate(" + (sl + 12) + "," + (st + 24) + ")";
      labels.attr('transform', pos);
    });

  var ltext = labels.append("text")
    .classed("label-text", true)
    .attr('z', 20)
    .text(function(d) {
      return d.id;
    })
    .each( // can't use d3 to create backing because order matters
      function () {
        let backing = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "rect"
        );
        backing.classList.add("backing");
        let mybb = this.getBBox();
        backing.setAttribute('x', mybb.x - 4);
        backing.setAttribute('y', mybb.y - 2);
        backing.setAttribute('width', mybb.width + 8);
        backing.setAttribute('height', mybb.height + 4);
        this.parentNode.insertBefore(backing, this);
      }
    );


  var node_titles = EGO_NODES.append("title")
    .text(function(d) {
      return (
        d.id
      + "\nInitiated: " + d.initiated
      + "\nReceived: " + d.received
      + "\nNeighbors: " + d.neighbors
      );
    });

  var edge_titles = EGO_LINKS.append("title")
    .text(
      function(d) {
        return (
          d.source.id + "→" + d.value + "→" + d.target.id
        );
      }
    );

  // Node divs on the sidebar:
  LISTING.selectAll("div").remove()
  LISTINGS = LISTING.selectAll("div")
    .data(visible_nodes)
    .enter().append("div")
  LISTINGS
    .classed("listing", true)
    .classed("selected", d => SELECTED_NODES.has(d.id))
    .each(function(d) { d.__ego_char__ = this; });
  sort_listings(document.getElementById("listing_sort").value);

  // Update symbols
  refresh_symbols();
}

function set_affinity(nodes, links) {
  // Sets up the affinity graph using the currently selected nodes, and first
  // ensuring that at least two nodes are selected. Each selected node is
  // arranged on the perimeter of a circle, and the rest of the nodes which
  // have at least some affinity for one or more selected nodes are arranged
  // inside it according to their relative affinity among the selected nodes,
  // or outside it if they have exclusive affinity for exactly one of the
  // selected nodes.
  ensure_at_least_two_selected();

  // Assign symbols:
  assign_auto(nodes);
}

function receive_data(graph) {
  // Build lookup tables for nodes from IDs and links from source/target IDs:
  graph.node_table = {};
  for (let node of graph.nodes) {
    graph.node_table[node.id] = node;
  }
  graph.link_table = {};
  for (let link of graph.links) {
    let sid = link.source;
    let tid = link.target;
    if (!graph.link_table.hasOwnProperty(sid)) {
      graph.link_table[sid] = {};
    }
    if (!graph.link_table.hasOwnProperty(tid)) {
      graph.link_table[tid] = {};
    }
    graph.link_table[sid][tid] = link;
    graph.link_table[tid][sid] = link;
  }
  graph.dlink_table = {};
  for (let link of graph.dlinks) {
    let sid = link.source;
    let tid = link.target;
    if (!graph.dlink_table.hasOwnProperty(sid)) {
      graph.dlink_table[sid] = {};
    }
    graph.dlink_table[sid][tid] = link;
  }

  // Sets up the system using the given graph data.
  GRAPH = graph;

  // We have to replace source/target ID refs with pointers:
  GRAPH.links.forEach(
    function (link) {
      link.source = lookup_node(link.source);
      link.target = lookup_node(link.target);
    }
  );
  GRAPH.dlinks.forEach(
    function (link) {
      link.source = lookup_node(link.source);
      link.target = lookup_node(link.target);
    }
  );

  // Find the neighborhood of each node:
  for (let node of GRAPH.nodes) {
    node.neighbors = 0;
    node.neighborhood = {};
    for (let link of GRAPH.links) {
      if (link.source === node && link.target !== node) {
        node.neighbors += 1;
        node.neighborhood[link.target.id] = link.target;
      } else if (link.target === node && link.source !== node) {
        node.neighbors += 1;
        node.neighborhood[link.source.id] = link.source;
      }
    }
  }

  select_graph(document.getElementById("graph_select").value);
}

function dragstarted(d) {
  if (!d3.event.active) {
    SIMULATION.alphaTarget(0.2).restart();
  }
  d.fx = d.x;
  d.fy = d.y;
}

function dragged(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function dragended(d) {
  if (!d3.event.active) {
    SIMULATION.alphaTarget(0);
  }
  d.fx = null;
  d.fy = null;
}

var SHOW_LINKS = {
  "major": true,
  "minor": true,
  "passive": true,
};
var COMPLETE_LEGEND = false;

function hoverstarted(d) {
  let node = d;
  if (LINKS) {
    d3.select(d.__label__).style("visibility", "visible");
    LINKS.style(
      "visibility",
      d => (
        (d.source === node || d.target === node)
        ? "visible"
        : "hidden"
      )
    );
  }
  if (EGO_LINKS) {
    d3.select(d.__ego_label__).style("visibility", "visible");
    EGO_LINKS.style(
      "visibility",
      d => (
        (d.source === node || d.target === node)
        ? "visible"
        : "hidden"
      )
    )
  }
}

function hoverended(d) {
  if (SELECTED_NODES.size > 0) {
    if (LINKS) {
      LINKS.style(
        "visibility",
        d => (
          SELECTED_NODES.has(d.source.id)
       || SELECTED_NODES.has(d.target.id)
        ) ? "visible" : "hidden"
      );
    }
    if (EGO_LINKS) {
      EGO_LINKS.style(
        "visibility",
        function (d) {
          if (SELECTED_NODES.size == 1 && SELECTED_NODES.has(EGO_CURRENT)) {
            return "visible";
          }
          if (d.source.id == EGO_CURRENT) {
            return SELECTED_NODES.has(d.target.id) ? "visible" : "hidden";
          } else if (d.target.id == EGO_CURRENT) {
            return SELECTED_NODES.has(d.source.id) ? "visible" : "hidden";
          }
        }
      );
    }
  } else {
    if (LINKS) {
      LINKS.style(
        "visibility",
        d => SHOW_LINKS[link_class(d)] ? "visible" : "hidden"
      )
    }
    if (EGO_LINKS) {
      EGO_LINKS.style("visibility", "visible");
    }
  }
  if (LINKS) {
    d3.select(d.__label__).style("visibility", "hidden");
  }
  if (EGO_LINKS) {
    d3.select(d.__ego_label__).style("visibility", "hidden");
  }
}

var SELECTED_NODES = new Set();
var SELECTION_ORDER = [];

function remove_array_item(arr, item) {
  for (let i = 0; i < arr.length; ++i) {
    if (arr[i] === item) {
      arr.splice(i, 1);
      i -= 1;
    }
  }
}

function clear_selection() {
  let sel = [];
  for (let id of SELECTION_ORDER) {
    sel.push(lookup_node(id));
  }
  for (let node of sel) {
    toggle_select(node, false);
  }
}

function toggle_select(node, on) {
  if (on) {
    remove_array_item(SELECTION_ORDER, node.id); // just in case
    node.__selected__ = true;
    SELECTED_NODES.add(node.id);
    SELECTION_ORDER.push(node.id);
    if (NODES) {
      NODES.classed("selected", d => SELECTED_NODES.has(d.id));
    }
    if (EGO_NODES) {
      EGO_NODES.classed("selected", d => SELECTED_NODES.has(d.id));
    }
    if (AFFINITY_NODES) {
      AFFINITY_NODES.classed("selected", d => SELECTED_NODES.has(d.id));
    }
    if (LISTINGS) {
      LISTINGS.classed("selected", d => SELECTED_NODES.has(d.id));
    }
    if (LINKS) {
      LINKS.style(
        "visibility",
        d => (
          SELECTED_NODES.has(d.source.id)
       || SELECTED_NODES.has(d.target.id)
        ) ? "visible" : "hidden"
      );
    }
    if (node.id == EGO_CURRENT) {
      d3.select("#eg_reselect").node().disabled = true;
    } else {
      d3.select("#eg_reselect").node().disabled = false;
    }
    d3.select("#eg_next").text(node.id);
  } else {
    node.__selected__ = false;
    SELECTED_NODES.delete(node.id);
    remove_array_item(SELECTION_ORDER, node.id);
    if (NODES) {
      NODES.classed("selected", d => SELECTED_NODES.has(d.id));
    }
    if (EGO_NODES) {
      EGO_NODES.classed("selected", d => SELECTED_NODES.has(d.id));
    }
    if (AFFINITY_NODES) {
      AFFINITY_NODES.classed("selected", d => SELECTED_NODES.has(d.id));
    }
    if (LISTINGS) {
      LISTINGS.classed("selected", d => SELECTED_NODES.has(d.id));
    }
    if (LINKS) {
      if (SELECTED_NODES.size == 0) {
        LINKS.style(
          "visibility",
          d => SHOW_LINKS[link_class(d)] ? "visible" : "hidden"
        );
      } else {
        LINKS.style(
          "visibility",
          d => (
            SELECTED_NODES.has(d.source.id)
         || SELECTED_NODES.has(d.target.id)
          ) ? "visible" : "hidden"
        );
      }
    }
    if (
      SELECTED_NODES.size == 0
    ) {
      d3.select("#eg_reselect").node().disabled = true;
      d3.select("#eg_next").text("");
    } else if (
      SELECTED_NODES.size == 1 && SELECTED_NODES.has(EGO_CURRENT)
    ) {
      d3.select("#eg_reselect").node().disabled = true;
      d3.select("#eg_next").text(EGO_CURRENT);
    } else {
      d3.select("#eg_reselect").node().disabled = false;
      d3.select("#eg_next").text(SELECTION_ORDER[SELECTION_ORDER.length-1]);
    }
  }
  let sel = {
    "initiated": new Set(),
    "received": new Set()
  };
  if (NODES) {
    let sel_data = NODES.data().filter(d => SELECTED_NODES.has(d.id));
    for (let d of sel_data) {
      sel.initiated.add(d.initiated);
      sel.received.add(d.received);
    }
  }
  BARS_GROUP.selectAll("rect.bar.initiated")
    .classed("selected", d => sel.initiated.has(d[0]));
  BARS_GROUP.selectAll("rect.bar.received")
    .classed("selected", d => sel.received.has(d[0]));
}

function toggle_legend_names(on) {
  COMPLETE_LEGEND = on;
  NODES.selectAll(".legend_label")
    .style("visibility", on ? "visible" : "hidden");
}

function toggle_link_visibility(cls, on) {
  SHOW_LINKS[cls] = on;
  LINKS_GROUP.selectAll("." + cls)
    .style("visibility", on ? "visible" : "hidden");
}

function toggle_node_filter(on) {
  if (!GRAPH) {
    return;
  }
  if (on) {
    let nodes = [];
    let links = [];
    for (let node of GRAPH.nodes) {
      if (node.group >= 2) {
        nodes.push(node);
      }
    }
    for (let link of GRAPH.links) {
      if (link.source.group >= 2 && link.target.group >= 2) {
        links.push(link);
      }
    }
    set_nodes_and_links(nodes, links);
    set_bars(nodes);
  } else {
    set_nodes_and_links(GRAPH.nodes, GRAPH.links);
    set_bars(GRAPH.nodes);
  }

  let n = SIMULATION.nodes().length;
  let bespan = document.getElementById("best_energy");
  if (bespan != null) {
    if (BEST_ENERGIES[n] == undefined) {
      bespan.innerHTML = "?";
    } else {
      bespan.innerHTML = BEST_ENERGIES[n].toExponential(3);
    }
  }
}

COLLAPSE_HISTOGRAMS = true;

function toggle_hist_collapse(on) {
  COLLAPSE_HISTOGRAMS = on;
  set_bars(GRAPH.nodes);
}

function sort_listings(sort_by) {
  let nodes = LISTING.selectAll("div").data();
  let sorted_nodes = [...nodes].sort(
    function(a, b) {
      if (sort_by == "default") {
        if (GRAPH_TYPE == "ego") {
          let a_flink = lookup_dlink(a.id, EGO_CURRENT);
          let b_flink = lookup_dlink(b.id, EGO_CURRENT);
          let a_rlink = lookup_dlink(EGO_CURRENT, a.id);
          let b_rlink = lookup_dlink(EGO_CURRENT, b.id);
          let a_fval = a_flink != undefined ? a_flink.value : 0;
          let b_fval = b_flink != undefined ? b_flink.value : 0;
          let a_rval = a_rlink != undefined ? a_rlink.value : 0;
          let b_rval = b_rlink != undefined ? b_rlink.value : 0;
          return (
            d3.descending(+(a.id == EGO_CURRENT), +(b.id == EGO_CURRENT))
         || d3.descending(a_fval + a_rval, b_fval + b_rval)
         || d3.descending(
              (a_fval > 0) + (a_rval > 0),
              (b_fval > 0) + (b_rval > 0)
            )
         || d3.descending(a_rval, b_rval)
         || d3.ascending(a.id, b.id)
          );
        } else {
          return (
            d3.descending(a.initiated, b.initiated)
         || d3.descending(a.received, b.received)
         || d3.ascending(a.id, b.id)
          );
        }
      } else if (sort_by == "category") {
        return (
          d3.descending(a.group, b.group)
       || d3.ascending(a.id, b.id)
        );
      } else if (sort_by == "name") {
        return (
          d3.ascending(a.id, b.id)
       || d3.descending(a.initiated + a.received, b.initiated + b.received)
        );
      } else if (sort_by == "initiated") {
        if (GRAPH_TYPE == "ego") {
          let a_flink = lookup_dlink(a.id, EGO_CURRENT);
          let b_flink = lookup_dlink(b.id, EGO_CURRENT);
          let a_rlink = lookup_dlink(EGO_CURRENT, a.id);
          let b_rlink = lookup_dlink(EGO_CURRENT, b.id);
          let a_fval = a_flink != undefined ? a_flink.value : 0;
          let b_fval = b_flink != undefined ? b_flink.value : 0;
          let a_rval = a_rlink != undefined ? a_rlink.value : 0;
          let b_rval = b_rlink != undefined ? b_rlink.value : 0;
          return (
            d3.descending(+(a.id == EGO_CURRENT), +(b.id == EGO_CURRENT))
         || d3.descending(a_fval, b_fval)
         || d3.descending(a_rval, b_rval)
         || d3.ascending(a.id, b.id)
          );
        } else {
          return (
            d3.descending(a.initiated, b.initiated)
         || d3.descending(a.received, b.received)
         || d3.ascending(a.id, b.id)
          );
        }
      } else if (sort_by == "received") {
        if (GRAPH_TYPE == "ego") {
          let a_flink = lookup_dlink(a.id, EGO_CURRENT);
          let b_flink = lookup_dlink(b.id, EGO_CURRENT);
          let a_rlink = lookup_dlink(EGO_CURRENT, a.id);
          let b_rlink = lookup_dlink(EGO_CURRENT, b.id);
          let a_fval = a_flink != undefined ? a_flink.value : 0;
          let b_fval = b_flink != undefined ? b_flink.value : 0;
          let a_rval = a_rlink != undefined ? a_rlink.value : 0;
          let b_rval = b_rlink != undefined ? b_rlink.value : 0;
          return (
            d3.descending(+(a.id == EGO_CURRENT), +(b.id == EGO_CURRENT))
         || d3.descending(a_rval, b_rval)
         || d3.descending(a_fval, b_fval)
         || d3.ascending(a.id, b.id)
          );
        } else {
          return (
            d3.descending(a.received, b.received)
         || d3.descending(a.initiated, b.initiated)
         || d3.ascending(a.id, b.id)
          );
        }
      } else if (sort_by == "total") {
        if (GRAPH_TYPE == "ego") {
          let a_flink = lookup_dlink(a.id, EGO_CURRENT);
          let b_flink = lookup_dlink(b.id, EGO_CURRENT);
          let a_rlink = lookup_dlink(EGO_CURRENT, a.id);
          let b_rlink = lookup_dlink(EGO_CURRENT, b.id);
          let a_fval = a_flink != undefined ? a_flink.value : 0;
          let b_fval = b_flink != undefined ? b_flink.value : 0;
          let a_rval = a_rlink != undefined ? a_rlink.value : 0;
          let b_rval = b_rlink != undefined ? b_rlink.value : 0;
          return (
            d3.descending(+(a.id == EGO_CURRENT), +(b.id == EGO_CURRENT))
         || d3.descending(a_fval + a_rval, b_fval + b_rval)
         || d3.descending(a_fval, b_fval)
         || d3.ascending(a.id, b.id)
          );
        } else {
          return (
            d3.descending(a.initiated + a.received, b.initiated + b.received)
         || d3.descending(a.initiated, b.initiated)
         || d3.ascending(a.id, b.id)
          );
        }
      } else if (sort_by == "neighbors") {
        return (
          d3.descending(a.neighbors, b.neighbors)
       || d3.descending(a.initiated, b.initiated)
       || d3.descending(a.initiated + a.received, b.initiated + b.received)
       || d3.ascending(a.id, b.id)
        );
      } else {
        console.warn("Invalid sort scheme: '" + sort_by + "'; defaulting.")
        return d3.ascending(a.id, b.id);
      }
    }
  );
  LISTING.selectAll("div").remove();
  LISTINGS = LISTING.selectAll("div")
    .data(sorted_nodes)
    .enter().append("div")

  LISTINGS
    .classed("listing", true)
    .classed("selected", d => SELECTED_NODES.has(d.id));

  var char_symbols = LISTINGS.append("span")
    .classed("symbol", true)
    .text(function (d) { return symbol_for(d); });
  var char_labels = LISTINGS.append("a")
    .text(function (d) { return d.id; })
    .attr("href", "#")
    .style("color", function(d) { return CAT_COLORS(d.group); })
    .on("click", d => toggle_select(d, !d.__selected__));

  // Add stats to listings:
  var lst_initiated = d => d.initiated;
  var lst_received = d => d.received;
  var lst_total = d => d.initiated + d.received;
  var lst_neighbors = d => d.neighbors;

  if (GRAPH_TYPE == "ego") {
    lst_initiated = function(d) {
      if (d.id == EGO_CURRENT) { return d.initiated; }
      let flink = lookup_dlink(d.id, EGO_CURRENT);
      return flink != undefined ? flink.value : 0;
    }
    lst_received = function(d) {
      if (d.id == EGO_CURRENT) { return d.received; }
      let rlink = lookup_dlink(EGO_CURRENT, d.id);
      return rlink != undefined ? rlink.value : 0;
    }
    lst_total = function(d) {
      return lst_initiated(d) + lst_received(d);
    }
    // neighbors is unchanged
  }

  LISTINGS.append("span")
    .classed("stats", true)
    .text(function(d) { return "🗣" + lst_initiated(d); })

  LISTINGS.append("span")
    .classed("stats", true)
    .text(function(d) { return "👂" + lst_received(d); })

  LISTINGS.append("span")
    .classed("stats", true)
    .text(function(d) { return "→" + lst_total(d); });

  LISTINGS.append("span")
    .classed("stats", true)
    .text(function(d) { return "⇔" + lst_neighbors(d); });
}

function filter_listings(string) {
  LISTINGS.style("display", function (d) {
    if (d.id.toLowerCase().includes(string.toLowerCase())) {
      return "grid";
    } else {
      return "none";
    }
  });
}

// In-line graph data
inline_data = undefined;

// Finally, load the data file or use the in-line data:
if (inline_data) {
  receive_data(inline_data);
} else {
  let data_file = "data/example-graph.json"; // the default
  let url = new URL(window.location.href);
  let target = url.searchParams.get("t");
  if (target) {
    data_file = target;
  }
  d3.json(
    data_file,
    function(error, graph) {
      if (error) throw error;
      receive_data(graph)
    }
  );
}

    </script>
  </body>
</html>
