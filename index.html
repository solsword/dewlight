<!doctype html>
<!-- From: https://bl.ocks.org/heybignick/3faf257bbbbc7743bb72310d03b86ee8 -->
<html>
  <head>
    <title>
      dewlight graph visualizer
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>

body {
  font-size: 14pt;
  line-height: 20pt;
  margin: 0pt;
  padding: 0pt;
  overflow: hidden;
}

#content {
  display: grid;
  grid-template-columns: 2fr 1fr;
  grid-template-rows: 20vh 80vh;
  grid-gap: 0pt;
  margin: 0pt;
  padding: 0pt;
  height: 100%;
  width: 100%;
  overflow: hidden;
}

h1 {
  font-size: larger;
  font-weight: bold;
  margin-bottom: 4pt;
}

#graphs {
  height: calc(80vh - 12pt);
  width: calc(66vw - 12pt);
  border: 1.5pt solid black;
  border-radius: 4pt;
  box-sizing: border-box;
  margin: 6pt;
  overflow: scroll;
  display: grid;
  grid-template-columns: 1fr;
  justify-items: center;
  align-items: center;
}
@media only screen and (max-width: 600px) {
  body {
    overflow: scroll;
  }

  #content {
    display: block;
    /*grid-template-columns: 1fr;*/
    height: auto;
    padding-top: 2em;
    overflow: scroll;
  }

  #controls {
    max-height: none !important;
  }

  #legend {
    max-height: none !important;
    height: auto !important;
  }

  #graphs {
    width: 95vw;
    margin: auto;
  }

  #sidebar {
    max-height: none !important;
  }

  #sidebar-controls {
    height: auto !important;
  }
}

.graph {
  width: 500px;
  height: 500px;
  display: none; /* Hide all graphs */
}

#force_directed {
  width: 1200px; /* User can scroll to see all of it */
  height: 1200px;
}

#histogram { /* Doesn't want standard sizing */
  width: 100%;
  height: 100%;
}

#controls {
  text-align: center;
  box-sizing: border-box;
  margin: 0pt;
  padding: 6pt;
  max-height: 20vh;
  overflow: scroll;
}

.graph_controls {
  margin: 0pt;
  padding: 0pt;
  display: none;
}

.graph_label {
  margin: 0pt;
}

#fd_controls {
  display: block; /* show at start */
}

#legend {
  box-sizing: border-box;
  margin: 0pt;
  max-height: 20vh;
  padding: 6pt;
  overflow: scroll;
}

#legend_entries {
  column-count: 2;
}

.swatch {
  display: inline-block;
  margin-right: 4pt;
  width: 12pt;
  height: 12pt;
}

#sidebar {
  max-height: 80vh;
  box-sizing: border-box;
  margin: 0pt;
  padding: 0pt;
  overflow: hidden;
}

#sidebar-controls {
  height: 20%;
  box-sizing: border-box;
  margin: 0pt;
  padding: 6pt;
}

#sidebar-controls > h1:first-child {
  margin-top: 0pt;
}

#sidebar-controls > p {
  margin: 6pt 0pt 6pt 0pt;
}


#listing {
  height: 80%;
  overflow: scroll;
  box-sizing: border-box;
  margin: 0pt;
}

a:link,a:visited {
  text-decoration: none;
  color: #005599;
}

.links line, .links path {
  fill: transparent;
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes .symbol {
  stroke: #fff;
  stroke-width: 1.5pt;
}

.selected .symbol {
  stroke: #000;
}

text.identity {
  text-anchor: middle;
  dominant-baseline: central;
  font-size: 19px;
  cursor: crosshair;
  fill: black;
  stroke: white;
  stroke-width: 1.5pt;
  paint-order: stroke fill;
}

.backing {
  fill: white;
  stroke: gray;
  rx: 4px;
  ry: 4px;
}

.edge {
  cursor: crosshair;
}

.directional-edge {
  cursor: crosshair;
}

.diredge-line {
  stroke: none;
  fill: #999;
}

.diredge-bubble {
  stroke: white;
  fill: #999;
  stroke-width: 1.5pt;
}

.diredge-label {
  text-anchor: middle;
  dominant-baseline: central;
  font-size: 19px;
  fill: black;
  stroke: white;
  stroke-width: 1.5pt;
  paint-order: stroke fill;
}

.edge-label {
  text-anchor: middle;
  dominant-baseline: central;
  font-size: 19px;
  fill: black;
  stroke: white;
  stroke-width: 1.5pt;
  paint-order: stroke fill;
}

rect.bar {
  cursor: crosshair;
}

rect.bar.selected {
  stroke: #000;
  stroke-width: 2pt;
}

.listing.selected a {
  text-decoration: underline;
  font-weight: bold;
}

.listing {
  display: grid;
  grid-template-columns: 1fr 8fr 2fr 2fr 2fr 2fr;
  border-bottom: 1pt dotted black;
}

.listing a:first-child {
  display: block;
  padding-left: 12pt;
  text-indent: -12pt;
}

.listing .stats {
  justify-self: start;
  align-self: center;
  font-size: smaller;
}

text {
  font-family: serif;
  font-size: 14pt;
}

#opt_spinner {
  display: none;
}

.nodes_diff.disabled {
  color: #aaa;
}

a.help {
  margin: 0pt 3pt 0pt 3pt;
  padding: 0pt 0pt 2pt 0pt;
  border: 1pt solid black;
  border-radius: 3pt;
  display: inline-block;
  box-sizing: border-box;
  width: 1.1em;
  height: 1.1em;
  text-align: center;
}

a.help.wide {
  width: auto;
  height: auto;
  padding: 0pt 2pt 0pt 2pt;
}

.UL {
  position: fixed;
  top: 4pt;
  left: 0pt; /* WHY?!? */
  margin: 0pt;
  padding: 0pt;
  background: white;
}

#help {
  position: fixed;
  width: 100vw;
  height: 100vh;
  overflow: scroll;
  margin: 0pt;
  box-sizing: border-box;
  padding: 0pt;
  visibility: hidden;
  background-color: rgba(0, 0, 0, 0.3);
}

#unhelp {
  position: fixed;
  top: 4pt;
  left: 0pt;
  margin: 0pt;
  padding: 0pt;
  padding-top: 0pt !important;
  font-size: larger;
  display: block;
}

#unhelp a {
  background: white;
}

#help h1,h2,h3,h4,h5,h6 {
  text-align: center;
  padding-top: 8pt;
}

#help_content {
  margin: 0pt auto 0pt auto;
  background: white;
  box-sizing: border-box;
  border-left: 2pt solid black;
  border-right: 2pt solid black;
  padding: 2.5em;
  max-width: 45em;
  text-align: justify;
}

#clear_filter {
  margin-left: 4pt;
}

    </style>
  </head>
  <body>
    <!-- floating link to help:about -->
    <h1 class="UL"><a class="help wide" href="#help:about">about</a></h1>
    <!-- help text (hidden but shown on click) -->
    <div id="help">
      <h1 id="unhelp"><a class="help wide" href="#">close help</a></h1>
      <!-- START OF HELP -->
      <div id="help_content">
        <a href="help.html" target="new">Open help page.</a>
      </div>
      <!-- END OF HELP -->
    </div>
    <div id="content">
      <!-- controls div in upper left -->
      <div id="controls">
        show <select id="graph_select" onchange="select_graph(this.value)">
          <option selected="t" value="force">relationships</option>
          <option value="ego">ego network</option>
          <option value="affinity">affinity plot</option>
          <option value="histogram">histograms</option>
        </select>
        |
        <input
         type="checkbox"
         id="node_filter"
         onclick="toggle_node_filter(this.checked)">
        core groups only
        |
        marker size
        <input
         type="range"
         min="4"
         max="20"
         step="2"
         value="12"
         id="size_slider"
         onchange="set_node_size(this.value)"
         >
         <!-- Note: value here overrides NODE_RADIUS initial setting -->
        <br/>

        <input
         type="button"
         value="clear selection"
         onclick="clear_selection();">
        |
        mark <select id="mark_select" onchange="set_identities(this.value)">
          <option selected="t" value="core">core nodes</option>
          <option value="ALL">all nodes</option>
          <option value="NONE">none</option>
        </select>
        |
        <input
         type="checkbox"
         id="node_transparency"
         onclick="toggle_node_transparency(this.checked)">
        transparency

        <br/>

        <div id="fd_controls" class="graph_controls">
          <h1 class="graph_label">
            All Relationships
            <a class="help" href="#help:relationships">?</a>
          </h1>

          hide
          <input
           type="checkbox"
           onclick="toggle_link_visibility('outside', !this.checked)">
          marginal edges
          <input
           type="checkbox"
           onclick="toggle_link_visibility('fringe', !this.checked)">
          passive edges
          <br/>

          <!--
          <input
           type="button"
           value="shuffle"
           onclick="shuffle()">
          |
          <input
           type="button"
           value="find optimum"
           onclick="optimize_randomly()">
          <img id="opt_spinner" src="res/loading.gif" alt="loading animation">
          |
          <input
           type="button"
           value="optimize"
           onclick="optimize_positions(SIMULATION)">
          |
          -->
          layout:
          <select id="layout_select" onchange="impose_layout(this.value)">
            <option value="strict">strict</option>
            <option selected="t" value="loose">loose</option>
            <option value="relaxed">relaxed</option>
          </select>
          |
          <input
           type="button"
           value="reset layout"
           onclick="impose_layout(document.getElementById('layout_select').value)"
           >
          |
          <input
           type="button"
           value="relax further"
           onclick="SIMULATION.alpha(MEDIUM_ENERGY).restart()">
          <br/>
          
          <!--
          energy: <span id="energy">?</span>
          | best: <span id="best_energy">?</span>
          <br/>
          -->
        </div>

        <div id="hs_controls" class="graph_controls">
          <h1 class="graph_label">
            Histograms
            <a class="help" href="#help:histograms">?</a>
          </h1>

          graph
          <select
           id="which_histogram"
           onchange="set_bars(GRAPH.nodes);">
            <option selected="t" value="initiated">initiated</option>
            <option value="received">received</option>
            <option value="interactions">
              interactions (initiated + received)
            </option>
            <option value="neighbors">neighbors</option>
          </select>
          |
          <input
           type="checkbox"
           id="double_histogram"
           checked="true"
           onclick="set_bars(GRAPH.nodes); document.getElementById('extra_histogram').disabled = !this.checked;">
          compare
          <select
           id="extra_histogram"
           onchange="set_bars(GRAPH.nodes);">
            <option value="initiated">initiated</option>
            <option selected="t" value="received">received</option>
            <option value="interactions">initiated+received</option>
            <option value="neighbors">neighbors</option>
          </select>
          <br/>

          <input
           type="checkbox"
           checked="true"
           onclick="toggle_hist_collapse(this.checked)">
          collapse values
          <br/>
        </div>

        <div id="eg_controls" class="graph_controls">
          <h1 class="graph_label">
            Ego Network
            <a class="help" href="#help:ego_network">?</a>
          </h1>

          viewing <span id="eg_name"></span>
          |
          <input
           type="button"
           id="eg_reselect"
           onclick="set_ego(GRAPH.nodes, GRAPH.dlinks)"
           value="switch to">
          <span id="eg_next"></span><br/>

          limit neighbors
          <select id="eg_cutoff" onchange="set_ego(GRAPH.nodes, GRAPH.dlinks)">
            <option selected="t" value="none">don't limit</option>
            <option value="3">top 3</option>
            <option value="5">top 5</option>
            <option value="10">top 10</option>
            <option value="15">top 15</option>
            <option value="20">top 20</option>
            <option value="30">top 30</option>
            <option value="aff>1">&gt;1 interaction</option>
            <option value="aff>2">&gt;2 interactions</option>
            <option value="aff>3">&gt;3 interactions</option>
            <option value="aff>5%">&gt;5% of highest</option>
            <option value="aff>10%">&gt;10% of highest</option>
            <option value="aff>25%">&gt;25% of highest</option>
            <option value="aff>50%">&gt;50% of highest</option>
            <option value="aff>75%">&gt;75% of highest</option>
            <option value="received">has link to</option>
            <option value="initiated">has link from</option>
            <option value="responded">has both links</option>
          </select>
        </div>

        <div id="af_controls" class="graph_controls">
          <h1 class="graph_label">
            Affinity Plot
            <a class="help" href="#help:affinity_plot">?</a>
          </h1>
          <input
           type="checkbox"
           id="show_outside_links"
           checked="t"
           onclick="toggle_outside_links(!this.checked);"
           > hide exterior links
          |
          <input
           type="checkbox"
           id="show_inside_links"
           onclick="toggle_inside_links(!this.checked);"
           > hide interior links
          |
          <input
           type="checkbox"
           id="affinity_edge_labels"
           checked="t"
           onclick="toggle_affinity_edge_labels(this.checked);"
           > label edges
          <br/>

          update outer
          <input
           type="button"
           id="add_outside_nodes"
           onclick="add_outside_nodes();"
           value="~"
           disabled="t"
           >
          <input
           type="button"
           id="remove_outside_nodes"
           onclick="remove_outside_nodes();"
           value="~"
           disabled="t"
           >
          |
          update inner
          <input
           type="button"
           id="add_inside_nodes"
           onclick="add_inside_nodes();"
           value="~"
           disabled="t"
           >
          <input
           type="button"
           id="remove_inside_nodes"
           onclick="remove_inside_nodes();"
           value="~"
           disabled="t"
           >
        </div>

      </div>
      <div id="legend">
        <h1>
          Legend
          <a class="help" href="#help:legend">?</a>
        </h1>
        <div id="legend_entries">
        </div>
      </div>
      <div id="graphs">
        <svg id="force_directed" class="graph"></svg>
        <svg id="histogram" class="graph"></svg>
        <svg id="ego" class="graph"></svg>
        <svg id="affinity" class="graph"></svg>
      </div>
      <div id="sidebar">
        <div id="sidebar-controls">
          <h1>
            Listing
            <a class="help" href="#help:listing">?</a>
          </h1>
          <p>
          sort by
          <select id="listing_sort" onchange="update_listings(this.value)"/>
            <option selected="t" value="default">default (by graph type)</option>
            <option value="group">group (then name)</option>
            <option value="name">name</option>
            <option value="initiated">initiated</option>
            <option value="received">received</option>
            <option value="total">total (then initiated)</option>
            <option value="neighbors">neighbors (then initiated)</option>
          </select>
          <br/>
          find
          <input
           type="text"
           id="listing_filter"
           oninput="filter_listings(this.value)"/><input
           type="button"
           value="clear"
           id="clear_filter"
           onclick="this.previousSibling.value = ''; filter_listings('')"/>
          </p>
        </div>
        <div id="listing">
        </div>
      </div>
    </div> <!-- content -->
    <script src="d3/d3.v4.min.js"></script>
    <script type="text/javascript">

const LARGE_GRAPH_WIDTH = 1200;
const LARGE_GRAPH_HEIGHT = 1200;
const SMALL_GRAPH_WIDTH = 500;
const SMALL_GRAPH_HEIGHT = 500;

// Alpha factors for resetting the simulation
const EXTREME_ENERGY = 1;
const HIGH_ENERGY = 0.5;
const MEDIUM_ENERGY = 0.25;
const LOW_ENERGY = 0.05;
const VERY_LOW_ENERGY = 0.02;

// ticks per period when cooling off the layout
const COOLOFF_TICKS = 100;

// Radius of nodes, adjusted by slider
const BASE_RADIUS = 10;
var NODE_RADIUS = 12;

// Font size for identity
const IDENTITY_FONT_BASE_SIZE = 16;

// Global handles for graphs:
var FDG = d3.select("#force_directed");
var FDG_CONTROLS = d3.select("#fd_controls");

var HIST = d3.select("#histogram");
var HIST_CONTROLS = d3.select("#hs_controls");

var EGO = d3.select("#ego");
var EGO_CONTROLS = d3.select("#eg_controls");

var AFFINITY = d3.select("#affinity");
var AFFINITY_CONTROLS = d3.select("#af_controls");

// Category styles
var CAT_COLOR_SCALE = d3.scaleOrdinal(d3.schemeCategory10);

var NODE_TRANSPARENCY = false;
function CAT_COLORS(n) {
  let cat_color = CAT_COLOR_SCALE(n);
  let result = d3.rgb(cat_color);
  if (NODE_TRANSPARENCY) {
    result.opacity = 0.6;
  }
  return result;
}

function CAT_SHAPES(n) {
  let shapes = [
    "diamond",
    "rounded",
    "square",
    "star_four",
    "hexagon",
    "star_five"
  ];
  n %= shapes.length;
  if (n < 0) { n += shapes.length; }
  return shapes[n];
}

// Histogram styles
var HIST_COLORS = {
  "initiated": "#ffc8e5",
  "received": "#e5c8ff",
  "interactions": "#e699e6",
  "neighbors": "#c8e5ff"
};

var HIST_BG_COLORS = {
  "initiated": "#f40083",
  "received": "#8300f4",
  "interactions": "#970097",
  "neighbors": "#0085f4"
};

var HIST_SHADING = {
  "initiated": "fwd_diag",
  "received": "back_diag",
  "interactions": "cross",
  "neighbors": "waves",
}

// Identity label variables
var IDENTITY_LISTS = {
  "Korean": "ㅁㄴㅇㅂㄷㅈㄱㅃㄸㅉㄲㅍㅌㅊㅋㅅㅎㅆㄹ",
  "Greek": "αβξδεφγθικλμνοπψρστυωχηζ",
  "English": "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
  "Arabic": "بدفتكطقذزسثشظصضغعءخحهمنرليو",
  "Devangari": "अइउऋऌएओकखगघङहचछजझञयशटठडढणरषतथदधनलसपफबभमव",
  "Japanese": "一二三四五六七八九十上中下正日大年会人本月長国出生子分東行同今高金時手見市力米自前円合立内事社者地京間田体学目後新明方部心民対主代言小思山実入回場野開万全定家北問話文動度県水安氏和政保表道相意発不党",
};
var DEFAULT_IDENTITY_SET = "English";
var GROUP_MAP = {
  //0: "Japanese",
  //1: "Devangari",
  "Main": "English",
  "Major": "English",
  "Minor": "English",
  "Marginal": "English",
  "Special": "English",
  "Nonce": "English",
}
var IDENTITY_MAP = {};

function zh_digit(d) {
  if (d == "0") {
    return "〇";
  } else if (d == "1") {
    return "一";
  } else if (d == "2") {
    return "二";
  } else if (d == "3") {
    return "三";
  } else if (d == "4") {
    return "四";
  } else if (d == "5") {
    return "五";
  } else if (d == "6") {
    return "六";
  } else if (d == "7") {
    return "七";
  } else if (d == "8") {
    return "八";
  } else if (d == "9") {
    return "九";
  }
}

const ZH_PLACES = [
  "",
  "十",
  "百",
  "千",
  "万"
];

function zh_numeral(digits, place) {
  // Note: doesn't work properly for just "0"
  // Note: Just aborts awkwardly above 99999
  if (place == undefined) {
    place = 0;
  }
  let d = digits[digits.length - 1];
  let rest = digits.slice(0, digits.length - 1);

  if (d == "0") { return ""; }

  if (digits.length > ZH_PLACES.length + 1) {
    console.warn("Warning: translating large number awkwardly: " + digits);
    let result = "";
    for (let digit of digits) {
      result += zh_digit(digit);
    }
    return result;
  }

  if (place >= ZH_PLACES.length) {
    console.error("Error: zh_numeral called with huge place value: " + place);
    let result = "";
    for (let digit of digits) {
      result += zh_digit(digit);
    }
    return result;
  }

  if (rest.length > 0) {
    return zh_numeral(rest, place + 1) + zh_digit(d) + ZH_PLACES[place];
  } else {
    return zh_digit(d) + ZH_PLACES[place];
  }
}

function nth_identity(group, n) {
  let ln = GROUP_MAP[group];
  if (ln == undefined) {
    GROUP_MAP[group] = DEFAULT_IDENTITY_SET;
    ln = DEFAULT_IDENTITY_SET;
  }
  if (ln == "Numeric") {
    return "" + (n+1);
  } else if (ln == "Numeric中文") {
    return zh_numeral("" + (n + 1));
  } else {
    let sl = IDENTITY_LISTS[ln];
    let result = "";
    while (n >= sl.length) {
      let div = Math.floor(n / sl.length);
      let mod = n % sl.length;
      result = sl[mod] + result;
      n = div-1;
    }
    result = sl[n] + result;
    return result;
  }
}

function automap_groups(data) {
  // Automatically assign different kinds of identity symbols to different
  // groups. 
  let group_sizes = {};
  let by_size = Object.keys(IDENTITY_LISTS).sort(
    x, y => IDENTITY_LISTS[x].length - IDENTITY_LISTS[y].length
  );
  GROUP_MAP = {}

  // Find all the group IDs
  for (let d of data) {
    GROUP_MAP[d.group] = 0;
    if (group_sizes.hasOwnProperty(d.group)) {
      group_sizes[d.group] += 1;
    } else {
      group_sizes[d.group] = 1;
    }
  }

  // Figure out the first identity list that's big enough for each group:
  let groups = Object.keys(GROUP_MAP);
  for (let gid of groups) {
    while (
      GROUP_MAP[gid] < by_size.length
   && IDENTITY_LISTS[by_size[GROUP_MAP[gid]]].length < group_sizes[gid]
   ) {
      GROUP_MAP[gid] += 1;
    }
    if (GROUP_MAP[gid] >= by_size.length) {
      console.warn(
        "Group of size " + group_sizes[gid] + " is too large for all available "
      + "identity lists."
      );
      GROUP_MAP[gid] -= 1;
    }
  }

  // Build histogram of usage of each symbols list:
  usage = [];
  usage.length = by_size.length; // extend
  for (let i = 0; i < groups.length; ++i) {
    let gid = groups[i];
    let idx = GROUP_MAP[gid];
    if (usage[idx] == undefined) {
      usage[idx] = 1;
    } else {
      usage[idx] += 1;
    }
  }

  // Separate identity assignment as much as possible:
  for (let i = 0; i < usage.length; ++i) {
    let overlap = usage[i];
    if (overlap != undefined && overlap > 1) {
      let free = 0;
      for (let j = i+1; j < usage.length; ++j) {
        if (usage[j] == undefined) {
          free += 1;
        } else {
          break;
        }
      }

      let move = Math.min(free, overlap - 1);
      for (let x = 0; x < move; ++x) {
        let reassign = undefined;
        for (gid of groups) {
          if (GROUP_MAP[gid] == i) {
            reassign = gid;
            break;
          }
        }
        if (reassign) {
          let old_list = GROUP_MAP[reassign];
          let new_list = old_list + x + 1;
          GROUP_MAP[reassign] = new_list;
          usage[old_list] -= 1;
          usage[new_list] += 1;
        }
      }
    }
  }

  // Re-express group map in terms of IDENTITY_LISTS keys:
  for (g of groups) {
    GROUP_MAP[g] = by_size[GROUP_MAP[g]];
  }

}

function set_identities(show_only) {
  assign_auto(GRAPH.nodes, show_only);
  refresh_identities();
}

function assign_auto(nodes, show_only) {
  if (show_only == undefined) {
    show_only = document.getElementById("mark_select").value;
  }
  if (show_only == "ALL") {
    assign_identities(GRAPH.nodes);
  } else if (show_only == "NONE") {
    assign_identities(GRAPH.nodes, []); // empty tag list prevents matches
  } else {
    assign_identities(GRAPH.nodes, [ show_only ]);
  }
}

function group_has_tag(group_id, tag) {
  return group_has_any_tag(group_id, [ tag ]);
}

function group_has_any_tag(group_id, tags_list) {
  for (let group_info of GRAPH.groups) {
    if (group_info.id == group_id) {
      for (let tag of tags_list) {
        if (group_info.tags.includes(tag)) {
          return true;
        }
      }
      return false;
    }
  }
  console.error("Group '" + group_id + "' is not listed in the graph!");
  return false;
}

function group_index(group_id) {
  if (GRAPH) {
    let group_objs = GRAPH.groups;
    for (let i = 0; i < group_objs.length; ++i) {
      if (group_objs[i].id == group_id) {
        return i;
      }
    }
    console.warn("Unindexed group: '" + group_id + "'");
    return -1;
  } else {
    return -1;
  }
}

function color_for_group(group_id) {
  return CAT_COLORS(group_index(group_id));
}

function solid_color_for_group(group_id) {
  return CAT_COLOR_SCALE(group_index(group_id));
}

function shape_for_group(group_id) {
  return CAT_SHAPES(group_index(group_id));
}

function assign_identities(data, limit_groups) {
  // Assign identities to each data ID using per-group identity lists:
  let current = {};
  // Identities are assigned based on total interactions, then initiations,
  // then ID:
  let sorted = [...data].sort(
    (a, b) => (
      d3.descending(a.initiated + a.received, b.initiated + b.received)
   || d3.descending(a.initiated, b.initiated)
   || d3.ascending(a.id, b.id)
    )
  );
  for (let d of sorted) {
    if (
        limit_groups != undefined
     && !group_has_any_tag(d.group, limit_groups)
    ) {
      IDENTITY_MAP[d.id] = "";
      continue;
    }
    let key = GROUP_MAP[d.group];
    if (key == undefined) {
      GROUP_MAP[d.group] = DEFAULT_IDENTITY_SET;
      key = DEFAULT_IDENTITY_SET;
    }
    let cur = current[key] || 0;
    IDENTITY_MAP[d.id] = nth_identity(d.group, cur);
    current[key] = cur + 1;
  }
}


function identity_for(d) {
  return IDENTITY_MAP[d.id]
}

function font_size_for_identity(d) {
  let id = identity_for(d);
  let fs = IDENTITY_FONT_BASE_SIZE * (NODE_RADIUS / BASE_RADIUS);
  return font_size_for_digits(id, fs, 0.7);
}

GRAPH_TYPE = "force";

function select_graph(type) {
  if (type == undefined) {
    type = GRAPH_TYPE;
  }
  GRAPH_TYPE = type;

  // Figure out target:
  if (type == "force") {
    target = "force_directed";
    controls = "fd_controls";
  } else if (type.slice(0,9) == "histogram") {
    target = "histogram";
    controls = "hs_controls";
  } else if (type == "ego") {
    target = "ego";
    controls = "eg_controls";
  } else if (type == "affinity") {
    target = "affinity";
    controls = "af_controls";
  } else {
    console.warn("Invalid graph type: '" + type + "'");
    target = "force_directed";
    controls = "fd_controls";
  }

  // Swap visibility:
  d3.selectAll(".graph").style("display", "none");
  d3.select("#" + target).style("display", "block");
  d3.selectAll(".graph_controls").style("display", "none");
  d3.select("#" + controls).style("display", "block");

  let viewport = d3.select("#graphs").node();
  let brect = viewport.getBoundingClientRect();
  let vp_width = +brect.width;
  let vp_height = +brect.height;
  // Scroll to middle if it's the force-directed graph:
  if (target == "force_directed") {
    if (LARGE_GRAPH_WIDTH > vp_width) {
      viewport.scrollLeft = LARGE_GRAPH_WIDTH/2 - vp_width/2;
    }
    if (LARGE_GRAPH_HEIGHT > vp_height) {
      viewport.scrollTop = LARGE_GRAPH_HEIGHT/2 - vp_height/2;
    }
  } else {
    if (SMALL_GRAPH_WIDTH > vp_width) {
      viewport.scrollLeft = SMALL_GRAPH_WIDTH/2 - vp_width/2;
    }
    if (SMALL_GRAPH_HEIGHT > vp_height) {
      viewport.scrollTop = SMALL_GRAPH_HEIGHT/2 - vp_height/2;
    }
  }

  // Update NODE_RADIUS
  set_node_size(document.getElementById("size_slider").value);

  // Actually (re)create the graph:
  if (type == "force") {
    set_nodes_and_links(GRAPH.nodes, GRAPH.links);
  } else if (type == "histogram") {
    set_bars(GRAPH.nodes);
  } else if (type == "ego") {
    set_ego(GRAPH.nodes, GRAPH.dlinks);
  } else if (type == "affinity") {
    set_affinity(GRAPH.nodes, GRAPH.links);
  } else {
    // Error messages was already generated above
    set_nodes_and_links(graph.nodes, graph.links);
  }

  // Setup legend:
  set_legend(type);

  // Enfoce link visibility
  set_link_visibility();
}

function set_legend(type) {
  if (type == "force" || type == "ego" || type == "affinity") {
    let in_use = [];
    for (let node of GRAPH.nodes) {
      if (in_use.indexOf(node.group) < 0) {
        in_use.push(node.group);
      }
    }

    let groups = GRAPH.groups.filter((x, i) => in_use.indexOf(x.id) >= 0);

    var legend = d3.select("#legend_entries");
    legend.selectAll("div").remove();
    var legend_entry = legend.selectAll("div")
      .data(groups)
      .enter().append("div");

    let legend_symbol = legend_entry.append("svg")
      .classed("swatch", true)

    let symbol_path = legend_symbol.append("path")
      .classed("symbol", true)
      .attr(
        "d",
        d => symbol_path_data([8, 8], 6, shape_for_group(d.id))
      )
      .attr("fill", d => color_for_group(d.id))

    legend_entry.append("span").text(d => d.id);
  } else if (type == "histogram") {
    let legend = d3.select("#legend_entries");
    legend.selectAll("div").remove();
    let legend_entry = legend.selectAll("div")
      .data(Object.keys(HIST_COLORS))
      .enter().append("div");

    let legend_symbol = legend_entry.append("svg")
      .classed("swatch", true)

    add_pattern_defs(legend_symbol)

    legend_symbol.append("rect")
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", 24)
      .attr("height", 24)
      .attr("fill", d => "url(#" + d + "-pattern)")

    legend_entry.append("span").text(d => d);
  } else {
    console.warn("Invalid graph type: '" + type + "'");
  }
}

// Custom bubble force to push marginal nodes out to the margins.
function forceBubble(target, radius, strength) {
  let nodes, targets, radii, strengths;

  let force = function(alpha) {
    let node, target, radius, strength;
    for (let i = 0; i < nodes.length; ++i) {
      node = nodes[i];
      target = targets[i];
      radius = radii[i];
      strength = strengths[i];
      let d = distance(node.x, node.y, target[0], target[1]);
      if (d < radius) {
        let fr = d/radius;
        let str = strength * Math.pow(1 - fr, 1/3);
        node.vx += (node.x - target[0]) * str * alpha;
        node.vy += (node.y - target[1]) * str * alpha;
      } else if (radius == 0) {
        // special case radius = 0 will attract w/ constant force
        node.vx += (target[0] - node.x) * strength * alpha;
        node.vy += (target[1] - node.y) * strength * alpha;
      } // otehrwise no effect
    }
  }

  function initialize() {
    if (!nodes) { return; }

    // populate local targets
    targets = new Array(nodes.length);
    for (let i = 0; i < nodes.length; i++) {
      targets[i] = target(nodes[i], i, nodes);
    }

    // populate local radii
    radii = new Array(nodes.length);
    for (let i = 0; i < nodes.length; i++) {
      radii[i] = radius(nodes[i], i, nodes);
    }

    // populate local strengths
    strengths = new Array(nodes.length);
    for (let i = 0; i < nodes.length; i++) {
      strengths[i] = strength(nodes[i], i, nodes);
    }
  }

  force.initialize = _ => {
    nodes = _;
    initialize();
  }

  force.target = _ => {
    if (_ == null) { return target; } // no arg so return value
    
    // coerce to function
    target = typeof _ === 'function' ? _ : () => _;

    // reinitialize
    initialize();

    // allow chaining
    return force;
  };

  force.radius = _ => {
    if (_ == null) { return radius; } // no arg so return value
    
    // coerce to function
    radius = typeof _ === 'function' ? _ : () => +_;

    // reinitialize
    initialize();

    // allow chaining
    return force;
  };

  force.strength = _ => {
    if (_ == null) { return strength; } // no arg so return value
    
    // coerce to function
    strength = typeof _ === 'function' ? _ : () => +_;

    // reinitialize
    initialize();

    // allow chaining
    return force;
  };

  if (!target) { target = [0, 0]; }
  if (!radius) { radius = 80; }
  if (!strength) { strength = 0.1; }

  force.target(target);
  force.radius(radius);
  force.strength(strength);

  return force;
}

function link_distance(link) {
  //return Math.max(10, 80 - Math.sqrt(link.value));
  return 10; // until a very near distance, always pull inwards
}

function link_strength(link) {
  // TODO: Make this (more) graph-agnostic?
  return (0.1 + 0.8 * (Math.log(link.value) / 6))/5;
}

link_forces = d3.forceLink()
  .id(function(d) { return d.id; })
  .distance(link_distance)
  .strength(link_strength);

separation_force = d3.forceManyBody()
  .strength(function () { return -360; })
  .distanceMax(50);

bubble_force = forceBubble()
  .target([LARGE_GRAPH_WIDTH/2, LARGE_GRAPH_HEIGHT/2])
  .radius(d => group_has_tag(d.group, "fringe") ? 240 : 160)
  .strength(d => group_has_any_tag(d.group, [ "fringe", "outside" ]) ? 0.4 : 0);

gather_force = forceBubble()
  .target([LARGE_GRAPH_WIDTH/2, LARGE_GRAPH_HEIGHT/2])
  .radius(0)
  .strength(0.025);

var SIMULATION = d3.forceSimulation()
  .force("link", link_forces)
  .force("charge", separation_force)
  .force("center", d3.forceCenter(LARGE_GRAPH_WIDTH/2, LARGE_GRAPH_HEIGHT/2))
  .force("bubble", bubble_force)
  .force("gather", gather_force);

function shuffle() {
  SIMULATION.nodes().forEach(function (n) {
    n.x = Math.random()*240;
    n.y = Math.random()*240;
  });
  SIMULATION.alpha(1).restart();
}

function distance(x1, y1, x2, y2) {
  return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
}

var BEST_ENERGIES = {};
var BEST_POSITIONS = {};

function compute_vel_energy(simulation, dont_track) {
  // Vel energy is simply computed by looking at the velocity of each node.
  // Even when the simulation cools, the cooling is applied *after* velocities
  // are computed, so this measure thoroughly accounts for all simulation
  // forces.
  e = 0;
  for (let node of simulation.nodes()) {
    e += Math.sqrt(node.vx * node.vx + node.vy * node.vy) / simulation.alpha();
  }
  // Track best energy
  if (!dont_track) {
    let n = simulation.nodes().length;
    if (BEST_ENERGIES[n] == undefined || e < BEST_ENERGIES[n]) {
      BEST_ENERGIES[n] = e;
      let bespan = document.getElementById("best_energy");
      if (bespan != null) {
        bespan.innerHTML = e.toExponential(3);
      }
      BEST_POSITIONS[n] = [];
      for (let node of simulation.nodes()) {
        BEST_POSITIONS[n].push([node.x, node.y]);
      }
    }
  }
  return e;
}

function compute_pull_energy(simulation, dont_track) {
  // Pull energy attempts to account for both stretched links (but it doesn't
  // penalize compressed links) and for the amount of charge force that's
  // applied across all nodes (roughly a measure of crowding).
  e = 0;
  // Add energy from stretched (but not compressed) links
  for (let link of simulation.force("link").links()) {
    let x1 = link.source.x;
    let y1 = link.source.y;
    let x2 = link.target.x;
    let y2 = link.target.y;
    let d = distance(x1, y1, x2, y2);
    let target_d = link_distance(link);
    if (d > target_d) {
      // TODO: Account for link_strength here?
      e += Math.pow(target_d - d, 2);
    }
  }
  // Add energy from charge force
  for (node of simulation.nodes()) {
    for (other of simulation.nodes()) {
      if (node === other) {
        continue;
      }
      let d = distance(node.x, node.y, other.x, other.y);
      let md = separation_force.distanceMax();
      if (d < md) {
        e += -separation_force.strength()() * (1 - d/md);
      }
    }
  }
  // Track best energy
  if (!dont_track) {
    let n = simulation.nodes().length;
    if (BEST_ENERGIES[n] == undefined || e < BEST_ENERGIES[n]) {
      BEST_ENERGIES[n] = e;
      let bespan = document.getElementById("best_energy");
      if (bespan != null) {
        bespan.innerHTML = e.toExponential(3);
      }
      BEST_POSITIONS[n] = [];
      for (let node of simulation.nodes()) {
        BEST_POSITIONS[n].push([node.x, node.y]);
      }
    }
  }
  return e;
}

function compute_stretch_energy(simulation, dont_track) {
  // Stretch energy is simply proportional to the total length of each link,
  // but weighted (linearly) according to the value of that link (total number
  // of interactions in either direction).
  e = 0;
  for (let link of simulation.force("link").links()) {
    let x1 = link.source.x;
    let y1 = link.source.y;
    let x2 = link.target.x;
    let y2 = link.target.y;
    let d = distance(x1, y1, x2, y2);
    e += d * link.value;
  }
  // Track best energy
  if (!dont_track) {
    let n = simulation.nodes().length;
    if (BEST_ENERGIES[n] == undefined || e < BEST_ENERGIES[n]) {
      BEST_ENERGIES[n] = e;
      let bespan = document.getElementById("best_energy");
      if (bespan != null) {
        bespan.innerHTML = e.toExponential(3);
      }
      BEST_POSITIONS[n] = [];
      for (let node of simulation.nodes()) {
        BEST_POSITIONS[n].push([node.x, node.y]);
      }
    }
  }
  return e;
}

// Select which energy implementation we're using:
//var compute_energy = compute_vel_energy;
//var compute_energy = compute_pull_energy;
var compute_energy = compute_stretch_energy;

function optimize_positions(simulation) {
  i = 0
  let n = simulation.nodes().length;
  if (BEST_POSITIONS[n] == undefined) {
    console.warn(
        "Can't optimize before any best positions have been observed."
    );
    return;
  }
  for (let node of simulation.nodes()) {
    node.x = BEST_POSITIONS[n][i][0];
    node.y = BEST_POSITIONS[n][i][1];
    i += 1;
  }
  simulation.alpha(1).restart();
}

function optimize_randomly() {
  // Calls mega_shuffle, but also shows a spinner while that's going on.
  // Reveal activity gif:
  let spinner = document.getElementById("opt_spinner");
  spinner.style.display = "inline";

  // Fire in two frames to allow GIF to load:
  window.requestAnimationFrame(
    function() { window.requestAnimationFrame(mega_shuffle); }
  );
}

function mega_shuffle() {
  // Shuffles 50 times and records the best configuration found, setting the
  // nodes into that configuration (approximately) at the end.

  // Run simulations:
  best = undefined;
  best_starts = undefined;
  for (let i = 0; i < 50; ++i) { // 50 trials
    SIMULATION.alpha(1); // reset alpha to 1
    SIMULATION.nodes().forEach(function (n) {
      n.x = Math.random()*20;
      n.y = Math.random()*20;
    });
    for (let j = 0; j < 3; ++j) { // tick and relax in 3 waves:
      for (let k = 0; k < 100; ++k) { // run 100 ticks
        SIMULATION.tick();
      }
      SIMULATION.alpha(1); // reset alpha to 1
    }
    for (let k = 0; k < 300; ++k) { // run another 300 ticks
      SIMULATION.tick();
    }
    compute_energy(SIMULATION, false); // compute final energy and record it
  }

  // Set node positions to best positions found:
  optimize_positions(SIMULATION);

  // Restart simulation one more time:
  SIMULATION.alpha(1).restart();

  // Hide spinner
  let spinner = document.getElementById("opt_spinner");
  spinner.style.display = "none";
}

function pos__key(pos) { return "" + pos[0] + "," + pos[1]; }
function key__pos(key) {
  let a = key.split(',');
  return [+a[0], +a[1]];
}

function simplex_neighbors(pos) {
  // All six neighbors in a simplex grid (horizontal straights; skewed right)
  return [
    [ pos[0] - 1, pos[1]],
    [ pos[0] - 1, pos[1] + 1],
    [ pos[0], pos[1] + 1],
    [ pos[0] + 1, pos[1]],
    [ pos[0] + 1, pos[1] - 1],
    [ pos[0], pos[1] - 1],
  ];
}

// Size of simplex grid:
const SIMPLEX_GRID_SIZE = 60;
// skew x and y values:
const SKX = Math.cos(Math.PI/3);
const SKY = Math.sin(Math.PI/3);

function simplex_coords(pos) {
  // Converts integer simplex coords into absolute SVG coordinates
  return [
    LARGE_GRAPH_WIDTH/2 + (pos[0] + SKX * pos[1]) * SIMPLEX_GRID_SIZE,
    LARGE_GRAPH_WIDTH/2 + SKY * pos[1] * SIMPLEX_GRID_SIZE
  ];
}

function hive_layout(nodes) {
  // A layout maps nodes <-> positions and keeps track of an edge
  let layout = {
    "positions": {}, // position of each node (by ID)
    "occupants": {}, // node at each position (by position key)
    "edge": new Set(), // set of edge positions (keys)
    "edge_order": [], // list of edge positions (positions)
  };
  // Add 0, 0 to edge:
  layout.edge.add(pos__key([0, 0]));
  layout.edge_order.push([0, 0]);

  // find first node; prepare to track interactions-with-placed-nodes
  let interactions = {};
  // incremental max for picking first node:
  let highest = 0;
  // next node for placement:
  let next = undefined;
  for (let node of nodes) {
    let ints = node.initiated + node.received;
    if (ints >= highest) {
      highest = ints;
      next = node;
    }
  }

  // Function for updating layout:
  function assign_pos(node, pos) {
    // Get position key:
    let k = pos__key(pos);

    // Set position of node:
    layout.positions[node.id] = pos;

    // Set occupant of position:
    if (layout.occupants[k] != undefined) {
      console.error("Double-assignment at pos: " + pos);
    }
    layout.occupants[k] = node;

    // Remove pos from edge set:
    if (!layout.edge.has(k)) {
      console.error("Assignment at non-edge: " + pos);
    }
    // And remove it from edge order:
    layout.edge.delete(k);
    let oidx = 0;
    for (; oidx < layout.edge_order.length; ++oidx) {
      let op = layout.edge_order[oidx];
      if (op[0] == pos[0] && op[1] == pos[1]) {
        break;
      }
    }
    if (oidx == layout.edge_order.length) {
      console.error("Failed to find pos in edge order: " + pos);
    } else {
      layout.edge_order.splice(oidx, 1);
    }

    // Add unoccupied neighbors to edge:
    for (let nb of simplex_neighbors(pos)) {
      let nbk = pos__key(nb);
      if (layout.occupants[nbk] == undefined && !layout.edge.has(nbk)) {
        layout.edge.add(nbk);
        layout.edge_order.push(nb);
      }
    }

    // Update interactions of neighbors of placed node:
    for (let nbid of node.neighborhood.values()) {
      let link = lookup_link(node.id, nbid);
      if (interactions.hasOwnProperty(nbid)) {
        interactions[nbid] += link.value;
      } else {
        interactions[nbid] = link.value;
      }
    }
  }

  function pick_next_node() {
    // Picks the next node to assign by looking for the node with the most
    // interactions with nodes that have already been placed. Ties are broken
    // according to total interactions and then neighborhood size.
    let best = undefined;
    let best_any = undefined;
    let best_neighbors = undefined;
    let result = undefined;

    function better_candidate(node) {
      // Favors nodes that have more interactions-with-placed-nodes, then
      // breaks ties using total-interactions, # of neighbors, group values,
      // and ID values in that order.
      let ints = interactions[node.id];
      let tot = node.initiated + node.received;
      let nbs = node.neighbors;
      // TODO: variable to switch these cases?
      if (best_any == undefined || tot > best_any) {
        return true;
      } else if (tot == best_any) {
        if (best_neighbors == undefined || nbs > best_neighbors) {
        } else if (nbs == best_neighbors) {
          if (
              result == undefined
           || group_index(node.group) > group_index(result.group)
          ) {
            return true;
          } else if (node.group == result.group) {
            if (d3.ascending(node.id, result.id) > 0) { // TODO: Check order?
              return true;
            }
          }
        }
      }
      /*
       * This version only counts interactions with nodes already placed.
      if (best == undefined || ints > best) {
        return true;
      } else if (ints == best) {
        if (best_any == undefined || tot > best_any) {
          return true;
        } else if (tot == best_any) {
          if (best_neighbors == undefined || nbs > best_neighbors) {
          } else if (nbs == best_neighbors) {
            if (result == undefined || node.group > result.group) {
              return true;
            } else if (node.group == result.group) {
              if (d3.ascending(node.id, result.id) > 0) { // TODO: Check order?
                return true;
              }
            }
          }
        }
      }
      */
      // fall out: we're not better
      return false;
    }
    for (let nid of Object.keys(interactions)) {
      // don't pick an already-assigned node:
      if (layout.positions.hasOwnProperty(nid)) { continue; }

      // check for a new best-so-far:
      let node = lookup_node(nid);
      if (better_candidate(node)) {
        best = interactions[nid];
        best_any = node.initiated + node.received;
        best_neighbors = node.neighbors;
        result = node;
      } // else move on to next node; this one isn't a new best-so-far
    }

    if (result == undefined) {
      // iterate through all nodes, not just those touching nodes seen so far:
      for (let node of nodes) {
        // don't pick an already-assigned node:
        if (layout.positions.hasOwnProperty(node.id)) { continue; }

        // check for a new best-so-far:
        if (better_candidate(node)) {
          best = interactions[node.id];
          best_any = node.initiated + node.received;
          best_neighbors = node.neighbors;
          result = node;
        }
      }
    }

    return result; // undefined if we're out of nodes
  }

  function best_position_for(node) {
    // Picks out the position among edge positions that minimizes the weighted
    // link lengths between this node and already-positioned nodes.

    // Gather all links with positioned nodes:
    let links = [];
    for (let nid of Object.keys(layout.positions)) {
      let link = lookup_link(node.id, nid);
      if (link != undefined) {
        links.push([link, nid]);
      }
    }

    // Iterate over edge positions:
    let best_energy = undefined;
    let nearest_origin = undefined;
    let candidate = undefined;
    for (let pos of layout.edge_order) {
      let energy = 0;
      let abs = simplex_coords(pos);
      for (let linkto of links) {
        let link = linkto[0];
        let oid = linkto[1];
        let oabs = simplex_coords(layout.positions[oid]);
        let v = [oabs[0] - abs[0], oabs[1] - abs[1]];
        let d = Math.sqrt(v[0]*v[0] + v[1]*v[1]);
        energy += d * link.value;
      }
      let origin = simplex_coords([0, 0]);
      let ov = [origin[0] - abs[0], origin[1] - abs[1]];
      let od = Math.sqrt(ov[0]*ov[0] + ov[1]*ov[1]);
      if (best_energy == undefined || energy < best_energy) {
        best_energy = energy;
        nearest_origin = od;
        candidate = pos;
      } else if (energy == best_energy) { // break ties towards origin
        if (nearest_origin == undefined || od < nearest_origin) {
          best_energy = energy;
          nearest_origin = od;
          candidate = pos;
        } // tie-break to earlier candidate by default
      }
    }
    if (candidate == undefined) {
      console.error("Failed to find best edge position:");
      console.error(node, layout);
    }

    return candidate;
  }

  // Set up hive rank counter:
  let rank = 0;

  // Keep assigning nodes to positions until we run out:
  do {
    next.__hive_rank__ = rank;
    rank += 1;
    target = best_position_for(next);
    assign_pos(next, target);
    next = pick_next_node();
  } while (next != undefined);

  // Return the final layout:
  return layout;
}

function impose_layout(type) {
  // Presets for impose_hive_layout
  if (type == "strict") {
    impose_hive_layout(SIMULATION);
  } else if (type == "loose") {
    impose_hive_layout(SIMULATION, VERY_LOW_ENERGY, 3);
  } else if (type == "relaxed") {
    impose_hive_layout(SIMULATION, MEDIUM_ENERGY, 5);
  } else {
    console.warn("Unknown layout preset: '" + type + "'");
    impose_hive_layout(SIMULATION, MEDIUM_ENERGY, 5);
  }
}

function impose_hive_layout(simulation, cooloff_alpha, cooloff_periods) {
  // Computes a hive layout, and then relaxes it a controlled amount. The
  // cooloff_alpha and cooloff_periods arguments can be left out, if
  // cooloff_alpha isn't given, then the simulation is fixed into the exact
  // hive layout; if cooloff_periods isn't given, then 3 cooloff periods are
  // used.
  if (cooloff_periods == undefined) {
    if (cooloff_alpha == undefined) {
      cooloff_periods = 0;
    } else {
      cooloff_periods = 3;
    }
  }

  let nodes = simulation.nodes();
  let layout = hive_layout(nodes);
  for (let node of nodes) {
    let pos = layout.positions[node.id];
    if (pos == undefined) {
      console.warn("Hive layout left node without position:", node, layout);
    }
    let abs = simplex_coords(pos);
    node.x = abs[0];
    node.y = abs[1];
    node.vx = 0;
    node.vy = 0;
  }
  let calpha = cooloff_alpha;
  if (calpha == undefined) {
    calpha = simulation.alphaMin()*2;
  }

  simulation.alpha(calpha).restart(); // restart w/ non-terminal alpha

  if (cooloff_periods == 0) {
    simulation.tick(); // tick once
  } else {
    for (let i = 0; i < cooloff_periods; ++i) {
      for (let j = 0; j < COOLOFF_TICKS; ++j) {
        simulation.tick();
      }
    }
    simulation.alpha(calpha); // keep up alpha
  }
  simulation.alpha(0); // prevent further updates
}

// Global data structures:
var ORIGINAL = null;
var FILTERED = null;
var GRAPH = null;

// Global d3 objects:
var LINKS = null;
var NODES = null;
var BARS = null;
var BARS_BELOW = null;
var LISTINGS = null;
var EGO_RANKING = null;
var EGO_CURRENT = null;
var EGO_NODES = null;
var EGO_LINKS = null;
var AFFINITY_NODES = null;
var AFFINITY_LINKS = null;

// Links groups before nodes groups here to get correct overlap:
var LINKS_GROUP = FDG.append("g").attr("class", "links");
var NODES_GROUP = FDG.append("g").attr("class", "nodes");
var LABELS_GROUP = FDG.append("g").attr("class", "labels");
var BARS_GROUP = HIST.append("g").attr("class", "bars");
var EGO_LINKS_GROUP = EGO.append("g").attr("class", "links");
var EGO_NODES_GROUP = EGO.append("g").attr("class", "nodes");
var AFFINITY_LINKS_GROUP = AFFINITY.append("g").attr("class", "links");
var AFFINITY_NODES_GROUP = AFFINITY.append("g").attr("class", "nodes");

// List of nodes in sidebar:
var LISTING = d3.select("#listing")

function link_class(link) {
  if (
      group_has_tag(link.source.group, "core")
   && group_has_tag(link.target.group, "core")
  ) {
    return "core";
  } else if (
      group_has_tag(link.source.group, "fringe")
   || group_has_tag(link.target.group, "fringe")
  ) {
    return "fringe";
  } else {
    return "outside";
  }
}

function refresh_identities() {
  // Updates identity symbols using the current identity assignment to update
  // the necessary SVG elements.

  // Force-directed graph
  if (NODES) {
    NODES.selectAll("text.identity").remove();
    NODES.append("text")
      .text(d => identity_for(d))
      .style("font-size", d => font_size_for_identity(d))
      .classed("identity", true)
      .attr('x', 0)
      .attr('y', 0)
      .on("mouseover", hoverstarted)
      .on("mouseout", hoverended)
      .on("click", d => toggle_select(d, !d.__selected__))
      .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));
  }

  // Ego graph
  if (EGO_NODES) {
    EGO_NODES.selectAll("text.identity").remove();
    EGO_NODES.append("text")
      .text(d => identity_for(d))
      .style("font-size", d => font_size_for_identity(d))
      .classed("identity", true)
      .attr('x', 0)
      .attr('y', 0)
      .on("mouseover", hoverstarted)
      .on("mouseout", hoverended)
      .on("click", d => toggle_select(d, !d.__selected__))
  }

  // Affinity graph
  if (AFFINITY_NODES) {
    AFFINITY_NODES.selectAll("text.identity").remove();
    AFFINITY_NODES.append("text")
      .text(d => identity_for(d))
      .style("font-size", d => font_size_for_identity(d))
      .classed("identity", true)
      .attr('x', 0)
      .attr('y', 0)
      .on("mouseover", hoverstarted)
      .on("mouseout", hoverended)
      .on("click", d => toggle_select(d, !d.__selected__))
  }

  // Sidebar
  LISTINGS.select("span.identity")
    .text(function (d) { return identity_for(d); });
}

function set_nodes_and_links(nodes, links) {
  // Assign identity:
  assign_auto(nodes);

  // Note: order that we add things here doesn't matter because they all go
  // into groups that are already ordered correctly for stacking.
  // Nodes:
  NODES_GROUP.selectAll("g").remove();
  NODES = NODES_GROUP.selectAll("g")
    .data(nodes)
    .enter().append("g");

  NODES
    .each(function(d) { d.__node__ = this; })
    .classed("selected", d => SELECTED_NODES.has(d.id));

  var node_titles = NODES.append("title")
    .text(function(d) {
      return (
        d.id
      + "\nInitiated: " + d.initiated
      + "\nReceived: " + d.received
      + "\nNeighbors: " + d.neighbors
      );
    });

  // Add symbols last so they sit on top of edges:  
  // TODO: Array bounds & wrapping!
  var symbols = NODES.append("path")
    .classed("symbol", true)
    .attr(
      "d",
      d => symbol_path_data([0, 0], NODE_RADIUS, shape_for_group(d.group))
    )
    .attr("fill", d => color_for_group(d.group))
    .style("stroke-width", Math.min(1.5, 1.5*(NODE_RADIUS/BASE_RADIUS)) + "pt")
    .style("cursor", "crosshair")
    .on("mouseover", hoverstarted)
    .on("mouseout", hoverended)
    .on("click", d => toggle_select(d, !d.__selected__))
    .call(d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended));

  LINKS_GROUP.selectAll("g").remove()
  LINKS = LINKS_GROUP.selectAll("g")
    .data(links)
    .enter().append("g");

  LINKS.each(function(d) { d.__edge__ = this; });

  // Edges go first so that they end up at the back:
  var edges = LINKS.append("line")
    .classed("edge", true)
    .attr(
      "stroke-width",
      function(d) { return d.value > 1 ? 0.5 + Math.sqrt(d.value) : 1; }
    );

  // After simulation links have been added
  LINKS.attr(
    "class",
    function(d) {
      let cls = link_class(d);
      return "link " + cls;
    }
  )
  .style(
    'visibility',
    function (d) {
      let cls = link_class(d);
      ["hidden", "visible"][+SHOW_LINKS[cls]];
    }
  );

  var edge_titles = LINKS.append("title")
    .text(
      function(d) {
        return d.source.id + "—" + d.value + "—" + d.target.id;
      }
    );

  // Labels last so they're over everything else:
  FDG.selectAll("g.label").remove();
  var labels = FDG.selectAll("g.label")
    .data(nodes)
    .enter().append("g");

  labels
    .classed("label", true)
    .attr(
      'transform',
      "translate("
    + (LARGE_GRAPH_WIDTH/4 + 12) + ","
    + (LARGE_GRAPH_HEIGHT/4 + 24) + ")"
    )
    .style('visibility', "hidden")
    .each(function(d) { d.__label__ = this; });

  // reposition labels if/when the graph is scrolled
  d3.select("#graphs")
    .on("scroll", function () {
      let st = this.scrollTop;
      let sl = this.scrollLeft;
      let pos = "translate(" + (sl + 12) + "," + (st + 24) + ")";
      labels.attr('transform', pos);
    });

  var ltext = labels.append("text")
    .classed("label-text", true)
    .attr('z', 20)
    .text(function(d) {
      return d.id;
    })
    .each( // can't use d3 to create backing because order matters
      function () {
        let backing = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "rect"
        );
        backing.classList.add("backing");
        let mybb = this.getBBox();
        backing.setAttribute('x', mybb.x - 4);
        backing.setAttribute('y', mybb.y - 2);
        backing.setAttribute('width', mybb.width + 8);
        backing.setAttribute('height', mybb.height + 4);
        this.parentNode.insertBefore(backing, this);
      }
    );

  // Node divs on the sidebar:
  set_listings_nodes(nodes);

  refresh_identities();

  function ticked() {
    edges
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    NODES
        .attr("transform", function(d) {
          return "translate(" + d.x + "," + d.y + ")";
        })

    let e = compute_energy(
        SIMULATION,
        SIMULATION.alpha() > SIMULATION.alphaMin()
    );

    let espan = document.getElementById("energy");
    if (espan != null) {
      espan.innerHTML = e.toExponential(3);
    }
  }

  SIMULATION
      .nodes(nodes)
      .on("tick", ticked);

  // Note: this is where link source/target IDs are replaced with source/target
  // node refs!
  SIMULATION.force("link")
      .links(links);

  SIMULATION.force("bubble").initialize(nodes);

  // the hive layout takes care of this, but otherwise it would be needed
  //SIMULATION.alpha(1).restart();

  // Impose selected hive layout:
  impose_layout(document.getElementById("layout_select").value);

  // Re-sort after layout to pick up layout ordering:
  update_listings();
}

BAR_TYPE = "initiated";

function font_size_for_digits(value, base_size, scale_factor) {
  if (scale_factor == undefined) {
    scale_factor = 0.92;
  }
  let llen = ("" + value).length;
  result = base_size * Math.pow(scale_factor, Math.max(llen-1, 0));
  if (result < 4) {
    console.warn(
      "Value '" + value + "' with base font size " + base_size + " resulted in "
    + "very small text (" + result + "pt)."
    );
  } else if (result < 2) {
    console.error(
      "Value '" + value + "' with base font size " + base_size + " resulted in "
    + "illegible text (" + result + "pt)."
    );
  }
  return result + "px";
}

function set_bars(data, above, below) {
  if (above != undefined && below == undefined) {
    plot = above;
  } else if (above != undefined) {
    plot = above + "+" + below;
  } else {
    if (document.getElementById("double_histogram").checked) {
      plot = (
        document.getElementById("which_histogram").value
      + "+" + document.getElementById("extra_histogram").value
      );
    } else {
      plot = document.getElementById("which_histogram").value;
    }
  }
  // Assign identities:
  assign_auto(data);

  if (plot == undefined) {
    plot = BAR_TYPE;
  }
  BAR_TYPE = plot;

  // Figure out size of histogram:
  let hist_width = +HIST.node().parentNode.getBoundingClientRect().width;
  let hist_height = +HIST.node().parentNode.getBoundingClientRect().height;

  // Compute selected bars:
  let sel = {};
  for (let prp of Object.keys(HIST_COLORS)) {
    sel[prp] = new Set();
  }
  let sel_data = data.filter(d => SELECTED_NODES.has(d.id));
  for (let d of sel_data) {
    for (let prp of Object.keys(HIST_COLORS)) {
      sel[prp].add(d[prp]);
    }
  }

  // Build histograms:
  let hist = [];

  let combo = false;
  let first, second;
  if (plot.indexOf("+") >= 0) {
    combo = true;
    first = plot.slice(0, plot.indexOf("+"));
    second = plot.slice(plot.indexOf("+") + 1);
  }

  for (let d of data) {
    if (combo) {
      let i = d[first];
      let r = d[second];
      if (hist[i]) {
        hist[i][0] += 1;
      } else {
        hist[i] = [1, 0];
      }
      if (hist[r]) {
        hist[r][1] += 1;
      } else {
        hist[r] = [0, 1];
      }
    } else {
      let val = d[plot];
      if (hist[val]) {
        hist[val] += 1;
      } else {
        hist[val] = 1;
      }
    }
  }

  let hbars = [];
  for (let i = 0; i < hist.length; ++i) {
    if (hist[i] == undefined && COLLAPSE_HISTOGRAMS) {
      continue; // don't add a bar
    }
    if (combo) {
      hbars.push([i, hist[i] || [0, 0]]);
    } else {
      hbars.push([i, hist[i] || 0]);
    }
  }
  let max_val;
  if (combo) {
    max_val = Math.max(...hbars.map(x => Math.max(...x[1])));
  } else {
    max_val = Math.max(...hbars.map(x => x[1]));
  }

  let bar_width = Math.max(
    24,
    (hist_width - 30) / Math.min(20, hbars.length)
  );

  if (combo) {
    function bar_height(d) {
      return (d/max_val) * (hist_height - 45)/2;
    }
    function bar_top(d) {
      return (hist_height - 30)/2 - bar_height(d[0]);
    }
    function bar_bot(d) {
      return (hist_height - 30)/2 + 30 + bar_height(d[1]);
    }
  } else {
    function bar_height(d) {
      return (d/max_val) * (hist_height - 45);
    }
    function bar_top(d) {
      return hist_height - 30 - bar_height(d);
    }
  }

  BARS_GROUP.selectAll("rect").remove();
  BARS = BARS_GROUP.selectAll("rect.bar.above")
    .data(hbars)
    .enter().append("rect");

  BARS
    .classed("bar", true)
    .classed("above", true)
    .attr('x', (d, i) => 15 + i*bar_width + bar_width/20)
    .attr('y', d => bar_top(d[1]))
    .attr('width', bar_width - bar_width/10)
    .on(
      "click",
      function (d) {
        let nodes = LISTINGS.data();
        let rect_node = this;
        let was_selected = rect_node.classList.contains("selected");
        for (let nd of nodes) {
          if (
            (plot == "combined" && nd.initiated == d[0])
         || nd[plot] == d[0]
          ) {
            toggle_select(nd, !was_selected);
          }
        }
      }
    );

  if (combo) {
    BARS
      .classed(first, true)
      .classed("selected", d => sel.initiated.has(d[0]))
      .attr('fill', "url(#" + first + "-pattern)")
      .attr('height', d => bar_height(d[1][0]));
  } else {
    BARS
      .classed(plot, true)
      .classed("selected", d => sel[plot].has(d[0]))
      .attr('fill', "url(#" + plot + "-pattern)")
      .attr('height', d => bar_height(d[1]));
  }

  BARS_GROUP.selectAll("text").remove();

  let names = [];
  let nd = [...data];
  nd.sort((a, b) => d3.ascending(a.id, b.id));
  if (combo) {
    nd.forEach(
      function(d) {
        if (names[d[first]]) {
          names[d[first]] += "\n" + d.id;
        } else {
          names[d[first]] = d.id;
        }
      }
    )
  } else {
    nd.forEach(
      function(d) {
        if (names[d[plot]]) {
          names[d[plot]] += "\n" + d.id;
        } else {
          names[d[plot]] = d.id;
        }
      }
    )
  }

  let bar_titles = BARS.append("title")
    .text(d => names[d[0]]);

  let ticks = BARS_GROUP.selectAll("text.tick")
    .data(hbars)
    .enter().append("text")
      .classed("tick", true)
      .text(d => d[0])
      .style("text-anchor", "middle")
      .style("font-size", (d, i) => font_size_for_digits(d[0], 12))
      .attr('x', (d, i) => 15 + i*bar_width + bar_width/2);

  if (combo) {
    ticks
      .attr('y', (hist_height/2))
      .style("dominant-baseline", "central");
  } else {
    ticks
      .attr('y', hist_height - 20)
      .style("dominant-baseline", "hanging");
  }

  let labels = BARS_GROUP.selectAll("text.label.above")
    .data(hbars)
    .enter().append("text")
      .classed("label", true)
      .classed("above", true)
      .style("text-anchor", "middle")
      .style("font-size", (d, i) => font_size_for_digits(d[0], 10))
      .attr('x', (d, i) => 15 + i*bar_width + bar_width/2);

  let lp = 4;
  let ll = 18;

  if (combo) {
    labels
      .classed(first, true)
      .text(d => d[1][0])
      .style("visibility", d => d[1][0] > 0 ? "visible" : "hidden")
      .attr('fill', d => bar_height(d[1][0]) > ll ? 'white': 'black')
      .attr(
        'y',
        d => bar_height(d[1][0]) > ll ? bar_top(d[1]) + lp: bar_top(d[1]) - lp
      )
      .style(
        "dominant-baseline",
        d => bar_height(d[1][0]) > ll ? "hanging": "baseline"
      );
  } else {
    labels
      .classed(plot, true)
      .text(d => d[1])
      .style("visibility", d => d[1] > 0 ? "visible" : "hidden")
      .attr('fill', d => bar_height(d[1]) > ll ? 'white': 'black')
      .attr(
        'y',
        d => bar_height(d[1]) > ll ? bar_top(d[1]) + lp: bar_top(d[1]) - lp
      )
      .style(
        "dominant-baseline",
        d => bar_height(d[1]) > ll ? "hanging": "baseline"
      );
  }

  // Extra bars going downwards:
  if (combo) {
    BARS_BELOW = BARS_GROUP.selectAll("rect.bar.below")
      .data(hbars)
      .enter().append("rect")
      .classed("bar", true)
      .classed("below", true)
      .classed(second, true)
      .classed("selected", d => sel[second].has(d[0]))
      .attr('x', (d, i) => 15 + i*bar_width + bar_width/20)
      .attr('width', bar_width - bar_width/10)
      .attr('height', d => bar_height(d[1][1]))
      .attr('y', (hist_height - 30)/2 + 30)
      .attr('fill', "url(#" + second + "-pattern)")
      .on(
        "click",
        function (d) {
          let chars = LISTINGS.data();
          let rect_node = this;
          let was_selected = rect_node.classList.contains("selected");
          for (let ch of chars) {
            if (ch[second] == d[0]) {
              toggle_select(ch, !was_selected);
            }
          }
        }
      );

    let bot_names = [];
    let nd = [...data];
    nd.sort((a, b) => d3.ascending(a.id, b.id));
    nd.forEach(
      function(d) {
        if (bot_names[d[second]]) {
          bot_names[d[second]] += "\n" + d.id;
        } else {
          bot_names[d[second]] = d.id;
        }
      }
    )

    let bot_titles = BARS_BELOW.append("title")
      .text(d => bot_names[d[0]]);

    let bot_labels = BARS_GROUP.selectAll("text.label.below")
      .data(hbars)
      .enter().append("text")
        .classed("label", true)
        .classed("below", true)
        .text(d => d[1][1])
        .style("visibility", d => d[1][1] > 0 ? "visible" : "hidden")
        .style("text-anchor", "middle")
        .style("font-size", (d, i) => font_size_for_digits(d[0], 10))
        .attr('x', (d, i) => 15 + i*bar_width + bar_width/2)
        .attr('fill', d => bar_height(d[1][1]) > ll ? 'white': 'black')
        .attr(
          'y',
          d => bar_height(d[1][1]) > ll ? bar_bot(d[1]) - lp: bar_bot(d[1]) + lp
        )
        .style(
          "dominant-baseline",
          d => bar_height(d[1][1]) > ll ? "baseline": "hanging"
        );
  }

  // overflow-x on #graphs + this = scroll
  d3.select("#histogram").style('width', (30 + bar_width * hbars.length)+"px");

  // Update listings
  set_listings_nodes(data);
}

function lookup_node(id, graph) {
  // Looks up a node by its ID value. Normally graph is left to default to the
  // global GRAPH.
  if (graph == undefined) {
    graph = GRAPH;
  }
  return graph.node_table[id];
}

function lookup_link(from_id, to_id) {
  // Looks up the canonical (undirected) edge between the nodes with the given
  // IDs, or returns undefined if there isn't one.
  if (!GRAPH.link_table.hasOwnProperty(from_id)) {
    return undefined; // no edges at all from that node
  }
  return GRAPH.link_table[from_id][to_id]; // okay if this is undefined
}

function lookup_dlink(from_id, to_id) {
  // Looks up the directed edge between the nodes with the given IDs, or returns
  // undefined if there isn't one.
  if (!GRAPH.dlink_table.hasOwnProperty(from_id)) {
    return undefined; // no outgoing edges from that node
  }
  return GRAPH.dlink_table[from_id][to_id]; // okay if this is undefined
}

function ensure_single_selected() {
  // Ensures that exactly one node is selected. Selects the node with the most
  // initiated + received interactions if none is already selected, or the
  // most-recently-selected node if multiple are selected.
  if (SELECTED_NODES.size == 0) {
    let sorted_nodes = [...GRAPH.nodes].sort(
      function(a, b) {
        return (
          d3.descending(a.initiated + a.received, b.initiated + b.received)
       || d3.descending(a.initiated, b.initiated)
       || d3.descending(a.received, b.received)
       || d3.ascending(a.id, b.id)
        );
      }
    );
    toggle_select(sorted_nodes[0], true);
  } else if (SELECTED_NODES.size > 1) {
    // deselect all but the most-recently-selected node
    let deselect = [];
    for (let i = 0; i < SELECTION_ORDER.length - 1; ++i) {
      deselect.push(SELECTION_ORDER[i]);
    }
    for (let i = 0; i < deselect.length; ++i) {
      toggle_select(lookup_node(deselect[i]), false);
    }
  }
}

function ensure_at_least_two_selected() {
  // Works like ensure_pair_selected, but does not deselect nodes if more than
  // two are selected.
  if (SELECTED_NODES.size < 2) {
    ensure_single_selected();
    let from_node = lookup_node(SELECTION_ORDER[0]);
    let links_touching = [];
    for (let link of GRAPH.links) {
      if (link.source === from_node || link.target === from_node) {
        links_touching.push(link);
      }
    }
    let best = 0;
    let chosen = undefined;
    for (let other of GRAPH.nodes) {
      let value = 0;
      for (let link of links_touching) {
        if ( // TODO: This could be more efficient (we know who comes first)
          (link.source == from_node && link.target === other)
       || (link.target == from_node && link.source === other)
        ) {
          value += link.value;
        }
      }
      if (value > best) {
        best = value;
        chosen = other;
      }
    }
    if (chosen == undefined) {
      chosen = GRAPH.nodes[0];
    }
    // Select that node
    toggle_select(chosen, true);

  } // don't do anything here...
}

function ensure_at_least_n_selected(n) {
  // Works like ensure_at_least_two_selected, but works for any given number n.
  // Fails if N is larger than the size of the graph, in which case it selects
  // the entire graph. Just selects nodes based on their interactions count.
  while (SELECTED_NODES.size < n) {
    let best = undefined;
    let chosen = undefined;
    for (let node of GRAPH.nodes) {
      if (SELECTED_NODES.has(node.id)) {
        continue; // already selected
      }
      if (best == undefined || node.interactions > best) {
        best = node.interactions;
        chosen = node;
      }
    }
    // Select that node
    toggle_select(chosen, true);
  }
}

function ensure_pair_selected() {
  // Ensures that exactly two nodes are selected. If more than two nodes are
  // selected, it deselects all but the most recent pair. Otherwise, it first
  // ensures that one node is selected (see ensure_single_selected) and then
  // adds the node that has the most interactions with that node (or just the
  // first node in the graph if that node has no interactions at all).

  if (SELECTED_NODES.size < 2) {
    ensure_at_least_two_selected();
  } else if (SELECTED_NODES.size > 2) { // too many selected
    // deselect all but the two most-recently-selected nodes
    let deselect = [];
    for (let i = 0; i < SELECTION_ORDER.length - 2; ++i) {
      deselect.push(SELECTION_ORDER[i]);
    }
    for (let i = 0; i < deselect.length; ++i) {
      toggle_select(lookup_node(deselect[i]), false);
    }
  }
}

function node_affinity(from, to) {
  // Returns an affinity value between the two nodes (the number of times
  // either entity spoke to the other). Returns zero for entities that have
  // never spoken to each other, and when the same node is both from and to,
  // unless that entity has talked to itself.
  // TODO: make this more efficient?
  let link = lookup_link(from.id, to.id);
  if (link) {
    return link.value;
  } else {
    return 0;
  }
}

function ego_layout_position(focus, node, visible_nodes) {
  // Returns an [x, y] array specifying the position for the given node in an
  // ego layout that's focused on the given focus node. Returns undefined for
  // nodes that aren't directly connected to the given focus node. Arranges
  // nodes in a spiral, starting with the most-interacting node on the right
  // and continuing clockwise, moving outwards to show relative strength of
  // connection.
  let s_width = +EGO.node().getBoundingClientRect().width;
  let s_height = +EGO.node().getBoundingClientRect().height;
  let dim = Math.max(1, Math.min(s_width, s_height));
  let visible_ranks = visible_nodes
    .filter(n => n.__ego_rank__ != undefined)
    .map(n => n.__ego_rank__.rank);
  visible_ranks.sort((a, b) => a - b);
  if (node === focus) {
    return [s_width / 2, s_height / 2];
  } else if (node.__ego_rank__ != undefined) {
    let this_visible_rank = visible_ranks.indexOf(node.__ego_rank__.rank);
    let theta = 0;
    let incr = 2*Math.PI / (visible_nodes.length-1);
    let aff = node.__ego_rank__.affinity;
    let max = EGO_RANKING[0].affinity;
    let r = (dim*.47) * (1 - (aff / max) / 2);
    return [
      s_width / 2 + Math.cos(theta + incr * this_visible_rank) * r,
      s_height / 2 + Math.sin(theta + incr * this_visible_rank) * r
    ];
  } else {
    // This node isn't ranked:
    return undefined;
  }
}

const MIN_LABEL_POS = 0.15; // limit for label positioning along links
const UNPAIRED_LABEL_POS = 0.3; // where to put unreciprocated labels

function edge_label_pos(link, get_elem) {
  // Computes the position for an edge label along a link. The provided
  // function must extract a d3 element from a node.
  let src_elem = get_elem(link.source);
  let trg_elem = get_elem(link.target);
  let src_transform = src_elem.transform.baseVal.consolidate().matrix;
  let trg_transform = trg_elem.transform.baseVal.consolidate().matrix;
  let src_pos = [src_transform.e, src_transform.f];
  let trg_pos = [trg_transform.e, trg_transform.f];

  let vector = [trg_pos[0] - src_pos[0], trg_pos[1] - src_pos[1]];

  // Forward and reverse values via dlink lookup:
  let dl_fwd = lookup_dlink(link.source.id, link.target.id);
  let dl_rev = lookup_dlink(link.target.id, link.source.id);

  let f_val = 0;
  let r_val = 0;
  if (dl_fwd != undefined) { f_val = dl_fwd.value; }
  if (dl_rev != undefined) { r_val = dl_rev.value; }

  let fr = 0.5; // safe default (but shouldn't happen)
  if (f_val + r_val != 0) {
    fr = f_val / (f_val + r_val);
  } else {
    console.error("edge_label_pos called for edge without interactions.");
    console.error(link);
  }

  let in_play = 1 - 2*MIN_LABEL_POS;

  // no gap because we've only got one number to display
  let sc = MIN_LABEL_POS + in_play * fr;

  return [src_pos[0] + vector[0] * sc, src_pos[1] + vector[1] * sc];
}

// Constant that controls the gap between fragments of directional edges:
const GAP_SIZE = 14;

function dir_edge_points(dlink, get_elem) {
  // Computes the edge points for a directional edge, given a function for
  // extracting a d3 element from a node (the provided directional link is
  // presumed to have node references as its source and target). The result
  // includes properties that specify two positions:
  //
  //  xs, ys: the start position
  //  xe, ye: the end position
  let src_elem = get_elem(dlink.source);
  let trg_elem = get_elem(dlink.target);
  let src_transform = src_elem.transform.baseVal.consolidate().matrix;
  let trg_transform = trg_elem.transform.baseVal.consolidate().matrix;
  let src_pos = [src_transform.e, src_transform.f];
  let trg_pos = [trg_transform.e, trg_transform.f];
  if (src_elem === trg_elem) {
    return {
      "xs": src_pos[0], "ys": src_pos[1],
      "xe": src_pos[0], "ye": src_pos[1],
    };
  } else {
    let vector = [trg_pos[0] - src_pos[0], trg_pos[1] - src_pos[1]];
    let mag = Math.sqrt(vector[0]*vector[0] + vector[1]*vector[1]);
    let ulink = lookup_link(dlink.source.id, dlink.target.id);
    let fr = dlink.value / ulink.value;
    let in_play = 1 - 2*MIN_LABEL_POS;
    let gap = GAP_SIZE/(in_play * mag);
    in_play -= gap;
    let sc = MIN_LABEL_POS + in_play * fr; // scale
    if (fr == 1) { // no opposite member; back off a bit
      sc = UNPAIRED_LABEL_POS;
    }
    return {
      "xs": src_pos[0], "ys": src_pos[1],
      "xe": src_pos[0] + sc * vector[0], "ye": src_pos[1] + sc * vector[1],
    };
  }
}

function filter_ego_node(node, cutoff) {
  if (node.id == EGO_CURRENT) {
    return true; // focus node always passes!
  }

  if (node.__ego_rank__ == undefined) {
    return false; // not even connected to our focus node
  }

  let in_link = lookup_dlink(node.id, EGO_CURRENT);
  let out_link = lookup_dlink(EGO_CURRENT, node.id);

  if (cutoff == "none") {
    return true;
  } else if (!isNaN(+cutoff)) {
    return node.__ego_rank__.rank < +cutoff;
  } else if (cutoff.slice(0, 4) == "aff>") {
    let threshold;
    if (cutoff.slice(cutoff.length - 1, cutoff.length) == "%") {
      let max = EGO_RANKING[0].affinity;
      let pct = +cutoff.slice(4, cutoff.length - 1);
      threshold = Math.floor(max * pct/100);
    } else {
      threshold = +cutoff.slice(4);
    }
    if (isNaN(threshold)) {
      console.error(
        "Invalid computed threshold value! Cutoff is: '" + cutoff + "'."
      );
      threshold = 1;
    }
    return node.__ego_rank__.affinity > threshold;
  } else if (cutoff == "received") {
    return out_link != undefined;
  } else if (cutoff == "initiated") {
    return in_link != undefined;
  } else if (cutoff == "responded") {
    return (in_link != undefined && out_link != undefined);
  }
}

function ego_sort(a, b) {
  return (
    d3.descending(a.affinity, b.affinity)
 || d3.descending(
      (a.initiated > 0) + (a.received > 0),
      (b.initiated > 0) + (b.received > 0)
    )
 || d3.descending(a.initiated, b.initiated)
 || d3.descending(group_index(a.node.group), group_index(b.node.group))
 || d3.ascending(a.node.id, b.node.id)
  );
}

function set_ego(nodes, dlinks) {
  // Sets up the ego graph, resetting the selection to be a single node (the
  // first one that was selected if several are now, or the most-interacting
  // node if no node is selected).
  ensure_single_selected();

  // Look up size of svg element:
  var s_width = +EGO.node().getBoundingClientRect().width;
  var s_height = +EGO.node().getBoundingClientRect().height;

  // Assign identity:
  assign_auto(nodes);

  // Get selected node:
  let focus_node = lookup_node(SELECTION_ORDER[0]);
  EGO_CURRENT = focus_node.id;

  // Set controls:
  d3.select("#eg_name")
    .text(focus_node.id)
    .style("color", color_for_group(focus_node.group));
  d3.select("#eg_reselect").node().disabled = true;
  d3.select("#eg_next")
    .text(focus_node.id)
    .style("color", "gray");

  // Compute affinities and rank nodes:
  EGO_RANKING = [];
  for (let node of nodes) {
    delete node.__ego_rank__;
    if (node != focus_node) {
      let aff = node_affinity(focus_node, node);
      if (aff > 0) {
        let olink = lookup_dlink(focus_node.id, node.id);
        let ilink = lookup_dlink(node.id, focus_node.id);
        let rank = {
          "affinity": aff,
          "initiated": olink != undefined ? olink.value : 0,
          "received": ilink != undefined ? ilink.value : 0,
          "node": node,
          "rank": 0
        };
        EGO_RANKING.push(rank);
        node.__ego_rank__ = rank;
      }
    }
  }

  // Sort in descending order by affinity scores:
  EGO_RANKING = EGO_RANKING.sort(ego_sort);

  let r = 0;
  for (let rank of EGO_RANKING) {
    rank.rank = r;
    r += 1;
  }

  // Check filters:
  let cutoff = document.getElementById("eg_cutoff").value;

  // Filter nodes and edges:
  let visible_nodes = nodes.filter(n => filter_ego_node(n, cutoff));
  let vnset = new Set();
  for (let node of visible_nodes) { vnset.add(node.id); }
  let relevant_edges = dlinks.filter(
    function (l) {
      if (l.source === focus_node) {
        return vnset.has(l.target.id);
      } else if (l.target === focus_node) {
        return vnset.has(l.source.id);
      } else {
        return false;
      }
    }
  );

  // Assign node positions:
  for (let node of visible_nodes) {
    node.__ego_pos__ = ego_layout_position(focus_node, node, visible_nodes);
  }

  // Set up nodes:
  EGO_NODES_GROUP.selectAll("g").remove();
  EGO_NODES = EGO_NODES_GROUP.selectAll("g")
    .data(visible_nodes)
    .enter().append("g");

  EGO_NODES.each(function(d) { d.__ego_node__ = this; });

  EGO_NODES
    .attr(
      "transform",
      function(d) {
        return "translate(" + d.__ego_pos__[0] + "," + d.__ego_pos__[1] + ")";
      }
    )
    .classed("selected", d => SELECTED_NODES.has(d.id));

  var circles = EGO_NODES.append("path")
    .classed("symbol", true)
    .attr(
      "d",
      d => symbol_path_data([0, 0], NODE_RADIUS, shape_for_group(d.group))
    )
    .attr("fill", d => color_for_group(d.group))
    .style("stroke-width", Math.min(1.5, 1.5*(NODE_RADIUS/BASE_RADIUS)) + "pt")
    .style("cursor", "crosshair")
    .on("mouseover", hoverstarted)
    .on("mouseout", hoverended)
    .on("click", d => toggle_select(d, !d.__selected__))
    .call(d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended));

  // Links
  EGO_LINKS_GROUP.selectAll("g").remove()
  EGO_LINKS = EGO_LINKS_GROUP.selectAll("g")
    .data(relevant_edges)
    .enter().append("g");

  EGO_LINKS.each(function(d) { d.__ego_edge__ = this; });

  var edges = EGO_LINKS.append("g")
    .classed("directional-edge", true)

  var edge_lines = edges.append("path")
    .classed("diredge-line", true)
    .attr(
      "stroke-width",
      function(d) { return d.value > 1 ? 0.5 + Math.sqrt(d.value) : 1; }
    );

  edge_lines
    .attr(
      "d",
      function(d) {
        let points = dir_edge_points(d, x => x.__ego_node__);
        return (
          "M " + points.xs + " " + points.ys
        + " L " + points.xe + " " + points.ye
        );
      }
    );

  var edge_labels = edges.append("text")
    .classed("diredge-label", true)
    .attr("x", d => dir_edge_points(d, x => x.__ego_node__).xe)
    .attr("y", d => dir_edge_points(d, x => x.__ego_node__).ye)
    .style("font-size", d => font_size_for_digits(d.value, 15, 1.0))
    .text(d => d.value);

  // node labels
  EGO.selectAll("g.label").remove();
  var labels = EGO.selectAll("g.label")
    .data(visible_nodes)
    .enter().append("g");

  labels
    .classed("label", true)
    .attr('transform', "translate(12, 24)")
    .style('visibility', "hidden")
    .each(function(d) { d.__ego_label__ = this; });

  // reposition labels if/when the graph is scrolled
  d3.select("#graphs")
    .on("scroll", function () {
      let st = this.scrollTop;
      let sl = this.scrollLeft;
      let pos = "translate(" + (sl + 12) + "," + (st + 24) + ")";
      labels.attr('transform', pos);
    });

  var ltext = labels.append("text")
    .classed("label-text", true)
    .attr('z', 20)
    .text(function(d) {
      return d.id;
    })
    .each( // can't use d3 to create backing because order matters
      function () {
        let backing = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "rect"
        );
        backing.classList.add("backing");
        let mybb = this.getBBox();
        backing.setAttribute('x', mybb.x - 4);
        backing.setAttribute('y', mybb.y - 2);
        backing.setAttribute('width', mybb.width + 8);
        backing.setAttribute('height', mybb.height + 4);
        this.parentNode.insertBefore(backing, this);
      }
    );


  var node_titles = EGO_NODES.append("title")
    .text(function(d) {
      return (
        d.id
      + "\nInitiated: " + d.initiated
      + "\nReceived: " + d.received
      + "\nNeighbors: " + d.neighbors
      );
    });

  var edge_titles = EGO_LINKS.append("title")
    .text(
      function(d) {
        return (
          d.source.id + "→" + d.value + "→" + d.target.id
        );
      }
    );

  // Node divs on the sidebar:
  //set_listings_nodes(visible_nodes);
  set_listings_nodes(nodes);

  // Update identities
  refresh_identities();
}

function set_listings_nodes(nodes) {
  // Sets which nodes are displayed in the listings
  LISTING.selectAll("div").remove()
  LISTINGS = LISTING.selectAll("div")
    .data(nodes)
    .enter().append("div")
  LISTINGS
    .classed("listing", true)
    .classed("selected", d => SELECTED_NODES.has(d.id))
    .each(function(d) { d.__node__ = this; });

  update_listings();
}

function reset_affinity_layout_info(graph) {
  // Resets the cached affinity layout for a graph.
  graph.__aff_layout__ = {};
}

function affinity_layout_position(graph, outside, node, outside_set, radius) {
  // Computes the position of a node in an affinity layout with the given
  // exterior nodes (if outside_set isn't supplied, it will be created
  // automatically). outside should be a list of node IDs, not nodes. The
  // radius is a scaling factor and defaults to 0.95.
  if (outside_set == undefined) {
    outside_set = new Set(outside);
  }

  if (radius == undefined) {
    radius = 0.92;
  }

  // Remember results:
  if (
    graph.__aff_layout__
 && graph.__aff_layout__.hasOwnProperty(radius)
 && graph.__aff_layout__[radius].hasOwnProperty(node.id)
  ) {
    return graph.__aff_layout__[radius][node.id];
  } else if (graph.__aff_layout__ == undefined) {
    graph.__aff_layout__ = {};
    graph.__aff_layout__[radius] = {};
  } else if (!graph.__aff_layout__.hasOwnProperty(radius)) {
    graph.__aff_layout__[radius] = {};
  }

  // Compute dimension for layout:
  let s_width = +AFFINITY.node().getBoundingClientRect().width;
  let s_height = +AFFINITY.node().getBoundingClientRect().height;
  let dim = Math.max(1, Math.min(s_width, s_height));

  if (outside_set.has(node.id)) { // an exterior node
    // outside nodes are pre-sorted
    rank = outside.indexOf(node.id);
    if (rank < 0) {
      console.error("Outside node '" + node.id + "' wasn't in outside list!");
    }
    let r = (dim/2) * radius;
    let theta = Math.PI * 2 * (rank / outside.length);
    let result = [
      SMALL_GRAPH_WIDTH/2 + r * Math.cos(theta),
      SMALL_GRAPH_HEIGHT/2 + r * Math.sin(theta)
    ];
    graph.__aff_layout__[radius][node.id] = result;
    return result;

  } else { // an interior node

    let pos = [0, 0];
    let weight = 0;
    for (let outer of outside) {
      let link = lookup_link(outer, node.id);
      let interactions = link != undefined ? link.value : 0;
      if (!outside_set.has(outer)) {
        console.error("Outside node '" + outer + "' is not in outside set!");
      }
      let opos = affinity_layout_position(
        GRAPH,
        outside,
        lookup_node(outer),
        outside_set,
        radius * 0.9
      );
      pos[0] += opos[0] * interactions;
      pos[1] += opos[1] * interactions;
      weight += interactions;
    }

    let result = [pos[0] / weight, pos[1] / weight];
    graph.__aff_layout__[radius][node.id] = result;
    return result;
  }
}

function set_affinity(nodes, links) {
  // Sets up the affinity graph using the currently selected nodes, first
  // ensuring that at least four nodes are selected. Each selected node is
  // arranged on the perimeter of a circle except the last, which is placed
  // inside the circle according to its relative affinity among the selected
  // nodes. Options for adding/removing nodes from the perimeter and center of
  // the affinity graph are made available.

  // Determine new outside and inside node groups if necessary:
  let outside = GRAPH.__aff_outside__;
  let inside = GRAPH.__aff_inside__;
  if (outside == undefined || inside == undefined) {
    ensure_at_least_n_selected(4);

    outside = [...SELECTION_ORDER];
    inside = [ outside[outside.length - 1] ];
    outside = outside.slice(0, outside.length - 1);
    GRAPH.__aff_outside__ = outside;
    GRAPH.__aff_inside__ = inside;

    clear_selection();
  }
  let visible_nodes = [];
  for (let nid of outside.concat(inside)) {
    visible_nodes.push(lookup_node(nid));
  }
  let is_outside = new Set(outside);
  let is_inside = new Set(inside);
  let relevant_edges = links.filter(
    function (l) {
      return (
        (is_outside.has(l.source.id) || is_inside.has(l.source.id))
     && (is_outside.has(l.target.id) || is_inside.has(l.target.id))
      );
    }
  );

  // Assign identity:
  assign_auto(nodes);

  // Sort outside nodes by interactions -> initiated
  outside.sort(
    function(a, b) {
      let na = lookup_node(a);
      let nb = lookup_node(b);
      return (
        d3.descending(na.interactions, nb.interactions)
     || d3.descending(na.initiated, nb.initiated)
     || d3.ascending(na.id, nb.id)
      );
    }
  );

  // Sort inside nodes by interactions -> initiated
  inside.sort(
    function(a, b) {
      let na = lookup_node(a);
      let nb = lookup_node(b);
      return (
        d3.descending(na.interactions, nb.interactions)
     || d3.descending(na.initiated, nb.initiated)
     || d3.ascending(na.id, nb.id)
      );
    }
  );

  // Assign node positions:
  reset_affinity_layout_info(GRAPH);
  for (let node of visible_nodes) {
    node.__aff_pos__ = affinity_layout_position(
      GRAPH,
      outside,
      node,
      is_outside
    );
  }

  // Nodes:
  AFFINITY_NODES_GROUP.selectAll("g").remove();
  AFFINITY_NODES = AFFINITY_NODES_GROUP.selectAll("g")
    .data(visible_nodes)
    .enter().append("g");

  AFFINITY_NODES
    .each(function(d) { d.__aff_node__ = this; })
    .classed("selected", d => SELECTED_NODES.has(d.id))
    .attr(
      "transform",
      d => "translate(" + d.__aff_pos__[0] + "," + d.__aff_pos__[1] + ")"
    );

  var node_titles = AFFINITY_NODES.append("title")
    .text(function(d) {
      return (
        d.id
      + "\nInitiated: " + d.initiated
      + "\nReceived: " + d.received
      + "\nNeighbors: " + d.neighbors
      );
    });

  // Add circles:
  var circles = AFFINITY_NODES.append("path")
    .classed("symbol", true)
    .attr(
      "d",
      d => symbol_path_data([0, 0], NODE_RADIUS, shape_for_group(d.group))
    )
    .attr("fill", d => color_for_group(d.group))
    .style("stroke-width", Math.min(1.5, 1.5*(NODE_RADIUS/BASE_RADIUS)) + "pt")
    .style("cursor", "crosshair")
    .on("mouseover", hoverstarted)
    .on("mouseout", hoverended)
    .on("click", d => toggle_select(d, !d.__selected__));

  // Links
  AFFINITY_LINKS_GROUP.selectAll("g").remove()
  AFFINITY_LINKS = AFFINITY_LINKS_GROUP.selectAll("g")
    .data(relevant_edges)
    .enter().append("g");

  AFFINITY_LINKS.each(function(d) { d.__aff_edge__ = this; });

  var edges = AFFINITY_LINKS.append("g")
    .classed("edge", true)

  var edge_lines = edges.append("line")
    .classed("line", true)
    .attr(
      "stroke-width",
      function(d) { return d.value > 1 ? 0.5 + Math.sqrt(d.value) : 1; }
    );

  edge_lines
    .attr("x1", d => d.source.__aff_pos__[0])
    .attr("y1", d => d.source.__aff_pos__[1])
    .attr("x2", d => d.target.__aff_pos__[0])
    .attr("y2", d => d.target.__aff_pos__[1])

  var edge_labels = edges.append("text")
    .classed("edge-label", true)
    .attr("x", d => edge_label_pos(d, x => x.__aff_node__)[0])
    .attr("y", d => edge_label_pos(d, x => x.__aff_node__)[1])
    .style("font-size", d => font_size_for_digits(d.value, 15, 1.0))
    .text(d => d.value);

  // node labels
  AFFINITY.selectAll("g.label").remove();
  var labels = AFFINITY.selectAll("g.label")
    .data(visible_nodes)
    .enter().append("g");

  labels
    .classed("label", true)
    .attr('transform', "translate(12, 24)")
    .style('visibility', "hidden")
    .each(function(d) { d.__aff_label__ = this; });

  // reposition labels if/when the graph is scrolled
  d3.select("#graphs")
    .on("scroll", function () {
      let st = this.scrollTop;
      let sl = this.scrollLeft;
      let pos = "translate(" + (sl + 12) + "," + (st + 24) + ")";
      labels.attr('transform', pos);
    });

  var ltext = labels.append("text")
    .classed("label-text", true)
    .attr('z', 20)
    .text(d => d.id)
    .each( // can't use d3 to create backing because order matters
      function () {
        let backing = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "rect"
        );
        backing.classList.add("backing");
        let mybb = this.getBBox();
        backing.setAttribute('x', mybb.x - 4);
        backing.setAttribute('y', mybb.y - 2);
        backing.setAttribute('width', mybb.width + 8);
        backing.setAttribute('height', mybb.height + 4);
        this.parentNode.insertBefore(backing, this);
      }
    );

  var edge_titles = AFFINITY_LINKS.append("title")
    .text(
      function (d) {
        let flink = lookup_dlink(d.source.id, d.target.id);
        let rlink = lookup_dlink(d.target.id, d.source.id);
        let fval = flink != undefined ? flink.value : 0;
        let rval = rlink != undefined ? rlink.value : 0;
        let s = d.value != 1 ? "s" : ""
        return (
          d.value + " interaction" + s + "\n"
        + d.source.id + "→" + d.target.id + ":" + fval + "\n"
        + d.target.id + "→" + d.source.id + ":" + rval
        );
      }
    );

  // Node divs on the sidebar:
  set_listings_nodes(nodes);

  // Update identities
  refresh_identities();

  // Update visibility from controls:
  toggle_outside_links();
  toggle_inside_links();
  toggle_affinity_edge_labels();

  // Make sure node diffs are current:
  update_node_diffs();
}

function add_outside_nodes() {
  let sel = [...SELECTION_ORDER];
  if (GRAPH.__aff_inside__ != undefined) {
    sel = sel.filter(x => GRAPH.__aff_inside__.indexOf(x) < 0);
  }
  if (GRAPH.__aff_outside__ == undefined) {
    if (sel.length < 2) {
      console.error("Too few selected nodes when updating outside nodes.");
    }
    GRAPH.__aff_outside__ = sel; // replace with selection
  } else {
    for (let nid of sel) {
      if (GRAPH.__aff_outside__.indexOf(nid) < 0) {
        GRAPH.__aff_outside__.push(nid);
      }
    }
  }
  set_affinity(GRAPH.nodes, GRAPH.links);
}

function remove_outside_nodes() {
  let sel = [...SELECTION_ORDER];
  if (GRAPH.__aff_outside__ == undefined) {
    console.error("Attempt to remove from outside nodes list before creation!");
  } else {
    for (let nid of sel) {
      let idx = GRAPH.__aff_outside__.indexOf(nid);
      if (idx >= 0) {
        GRAPH.__aff_outside__.splice(idx, 1);
      }
    }
    if (GRAPH.__aff_outside__.length < 2) {
      console.error("Removed too many outside nodes!");
    }
  }
  set_affinity(GRAPH.nodes, GRAPH.links);
}

function add_inside_nodes() {
  let sel = [...SELECTION_ORDER];
  if (GRAPH.__aff_outside__ != undefined) {
    sel = sel.filter(x => GRAPH.__aff_outside__.indexOf(x) < 0);
  }
  if (GRAPH.__aff_inside__ == undefined) {
    if (sel.length < 2) {
      console.error("Too few selected nodes when updating inside nodes.");
    }
    GRAPH.__aff_inside__ = sel; // replace with selection
  } else {
    for (let nid of sel) {
      if (GRAPH.__aff_inside__.indexOf(nid) < 0) {
        GRAPH.__aff_inside__.push(nid);
      }
    }
  }
  set_affinity(GRAPH.nodes, GRAPH.links);
}

function remove_inside_nodes() {
  let sel = [...SELECTION_ORDER];
  if (GRAPH.__aff_inside__ == undefined) {
    console.error("Attempt to remove from inside nodes list before creation!");
  } else {
    for (let nid of sel) {
      let idx = GRAPH.__aff_inside__.indexOf(nid);
      if (idx >= 0) {
        GRAPH.__aff_inside__.splice(idx, 1);
      }
    }
  }
  set_affinity(GRAPH.nodes, GRAPH.links);
}

var SHOW_OUTSIDE_LINKS = false;
var SHOW_INSIDE_LINKS = true;
var SHOW_AFFINITY_LINK_LABELS = true;

function toggle_outside_links(on) {
  if (on == undefined) {
    on = !document.getElementById("show_outside_links").checked;
  }

  SHOW_OUTSIDE_LINKS = on;
  set_link_visibility();
}

function toggle_inside_links(on) {
  if (on == undefined) {
    on = !document.getElementById("show_inside_links").checked;
  }

  SHOW_INSIDE_LINKS = on;
  set_link_visibility();
}

function toggle_affinity_edge_labels(on) {
  if (on == undefined) {
    on = document.getElementById("affinity_edge_labels").checked;
  }

  SHOW_AFFINITY_LINK_LABELS = on;
  set_link_visibility();
}


function augment_graph(graph) {
  // Build lookup tables for nodes from IDs and links from source/target IDs:
  graph.node_table = {};
  for (let node of graph.nodes) {
    graph.node_table[node.id] = node;
  }
  graph.link_table = {};
  for (let link of graph.links) {
    let sid = link.source;
    let tid = link.target;
    if (!graph.link_table.hasOwnProperty(sid)) {
      graph.link_table[sid] = {};
    }
    if (!graph.link_table.hasOwnProperty(tid)) {
      graph.link_table[tid] = {};
    }
    graph.link_table[sid][tid] = link;
    graph.link_table[tid][sid] = link;
  }
  graph.dlink_table = {};
  for (let link of graph.dlinks) {
    let sid = link.source;
    let tid = link.target;
    if (!graph.dlink_table.hasOwnProperty(sid)) {
      graph.dlink_table[sid] = {};
    }
    graph.dlink_table[sid][tid] = link;
  }

  // We have to replace source/target ID refs with pointers:
  graph.links.forEach(
    function (link) {
      link.source = lookup_node(link.source, graph);
      link.target = lookup_node(link.target, graph);
    }
  );
  graph.dlinks.forEach(
    function (link) {
      link.source = lookup_node(link.source, graph);
      link.target = lookup_node(link.target, graph);
    }
  );

  // Augment nodes:
  for (let node of graph.nodes) {
    // (re?) compute initiated/received and interactions from dlinks
    node.initiated = 0;
    node.received = 0;
    node.interactions = 0;
    // Find neighborhood:
    node.neighbors = 0;
    node.neighborhood = new Set();
    for (let link of graph.dlinks) {
      if (link.source === node) {
        node.initiated += link.value;
        node.interactions += link.value;
        if (link.target !== node && !node.neighborhood.has(link.target.id)) {
          node.neighbors += 1;
          node.neighborhood.add(link.target.id);
        }
      } else if (link.target === node) {
        node.received += link.value;
        node.interactions += link.value;
        if (link.source !== node && !node.neighborhood.has(link.source.id)) {
          node.neighbors += 1;
          node.neighborhood.add(link.source.id);
        }
      }
    }
  }
}

function receive_data(graph) {
  // Sets up the system using the given graph data.
  ORIGINAL = graph;

  // Lock down colors so they don't depend on which view we enter first:
  for (let node of graph.nodes) {
    color_for_group(node.group);
  }

  // must happen pre-augment; augments result
  FILTERED = filter_raw_graph(graph);

  augment_graph(graph); // augment this graph

  let use_filtered = document.getElementById("node_filter").checked;
  if (use_filtered) {
    GRAPH = FILTERED;
  } else {
    GRAPH = ORIGINAL;
  }

  select_graph(document.getElementById("graph_select").value);
}

var DRAG_STARTED_AT = undefined;
const DRAG_DELAY = 50; // milliseconds

function dragstarted(d) {
  if (!d3.event.active) {
    DRAG_STARTED_AT = performance.now();
  }
  d.fx = d.x;
  d.fy = d.y;
}

function dragged(d) {
  if (
    DRAG_STARTED_AT != undefined
 && performance.now() - DRAG_STARTED_AT > DRAG_DELAY
  ) {
    DRAG_STARTED_AT = undefined;
    SIMULATION.alphaTarget(MEDIUM_ENERGY).restart();
  }
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function dragended(d) {
  if (!d3.event.active) {
    SIMULATION.alphaTarget(0);
  }
  d.fx = null;
  d.fy = null;
}

var SHOW_LINKS = {
  "core": true,
  "outside": true,
  "fringe": true,
};
var COMPLETE_LEGEND = false;

function link_touches(link, node) {
  return link.source === node || link.target === node;
}

function touches_selected(link) {
  return (
    SELECTED_NODES.has(link.source.id)
 || SELECTED_NODES.has(link.target.id)
  );
}

function link_visibility(link, focus_node) {
  if (focus_node != undefined) {
    return link_touches(link, focus_node) ? "visible" : "hidden";
  } else {
    if (SELECTED_NODES.size > 0) { // selection overrules
      return touches_selected(link) ? "visible": "hidden";
    } else { // settings value
      return SHOW_LINKS[link_class(link)] ? "visible" : "hidden";
    }
  }
}

function ego_link_visibility(link, focus_node) {
  if (focus_node != undefined) {
    return link_touches(link, focus_node) ? "visible" : "hidden";
  } else {
    if (SELECTED_NODES.size > 0) { // selection takes precedence
      if (SELECTED_NODES.size == 1 && SELECTED_NODES.has(EGO_CURRENT)) {
        return "visible";
      }
      if (link.source.id == EGO_CURRENT) {
        return SELECTED_NODES.has(link.target.id) ? "visible" : "hidden";
      } else if (link.target.id == EGO_CURRENT) {
        return SELECTED_NODES.has(link.source.id) ? "visible" : "hidden";
      }
    } else { // nothing selected
      return "visible";
    }
  }
}

function affinity_link_visibility(link, focus_node) {
  if (focus_node != undefined) {
    return link_touches(link, focus_node) ? "visible" : "hidden";
  } else {
    if (!SHOW_OUTSIDE_LINKS) { // check setting first
      if (
        GRAPH.__aff_outside__.indexOf(link.source.id) >= 0
     && GRAPH.__aff_outside__.indexOf(link.target.id) >= 0
      ) {
        return "hidden";
      } // else cascade onwards to check selection etc.
    }

    if (!SHOW_INSIDE_LINKS) {
      if (
        GRAPH.__aff_inside__.indexOf(link.source.id) >= 0
     && GRAPH.__aff_inside__.indexOf(link.target.id) >= 0
      ) {
        return "hidden";
      } // else cascade onwards to check selection etc.
    }

    if (SELECTED_NODES.size > 0) { // selection takes precedence
      return touches_selected(link) ? "visible": "hidden";
    } else { // nothing selected
      return "visible";
    }
  }
}

function set_link_visibility(focus_node) {
  if (LINKS) {
    LINKS.style("visibility", d => link_visibility(d, focus_node));
  }
  if (EGO_LINKS) {
    EGO_LINKS.style("visibility", d => ego_link_visibility(d, focus_node));
  }
  if (AFFINITY_LINKS) {
    AFFINITY_LINKS.style(
      "visibility",
      d => affinity_link_visibility(d, focus_node)
    );
    AFFINITY_LINKS.selectAll("text.edge-label")
      .style(
        "visibility",
        d => affinity_link_visibility(d, focus_node) == "hidden"
             ? "hidden"
             : (SHOW_AFFINITY_LINK_LABELS ? "visible" : "hidden")
      );
  }
}

function hoverstarted(d) {
  set_link_visibility(d);
  if (d.__label__ != undefined) {
    d3.select(d.__label__).style("visibility", "visible");
  }
  if (d.__ego_label__ != undefined) {
    d3.select(d.__ego_label__).style("visibility", "visible");
  }
  if (d.__aff_label__ != undefined) {
    d3.select(d.__aff_label__).style("visibility", "visible");
  }
}
function hoverended(d) {
  set_link_visibility();
  if (d.__label__ != undefined) {
    d3.select(d.__label__).style("visibility", "hidden");
  }
  if (d.__ego_label__ != undefined) {
    d3.select(d.__ego_label__).style("visibility", "hidden");
  }
  if (d.__aff_label__ != undefined) {
    d3.select(d.__aff_label__).style("visibility", "hidden");
  }
}

var SELECTED_NODES = new Set();
var SELECTION_ORDER = [];

function remove_array_item(arr, item) {
  for (let i = 0; i < arr.length; ++i) {
    if (arr[i] === item) {
      arr.splice(i, 1);
      i -= 1;
    }
  }
}

function clear_selection() {
  let sel = [];
  for (let id of SELECTION_ORDER) {
    sel.push(lookup_node(id));
  }
  for (let node of sel) {
    toggle_select(node, false);
  }
}

function toggle_select(node, on) {
  if (on) {
    remove_array_item(SELECTION_ORDER, node.id); // just in case
    node.__selected__ = true;
    SELECTED_NODES.add(node.id);
    SELECTION_ORDER.push(node.id);
    if (NODES) {
      NODES.classed("selected", d => SELECTED_NODES.has(d.id));
    }
    if (EGO_NODES) {
      EGO_NODES.classed("selected", d => SELECTED_NODES.has(d.id));
    }
    if (AFFINITY_NODES) {
      AFFINITY_NODES.classed("selected", d => SELECTED_NODES.has(d.id));
    }
    if (LISTINGS) {
      LISTINGS.classed("selected", d => SELECTED_NODES.has(d.id));
    }
    if (LINKS) {
      LINKS.style(
        "visibility",
        d => (
          SELECTED_NODES.has(d.source.id)
       || SELECTED_NODES.has(d.target.id)
        ) ? "visible" : "hidden"
      );
    }
    if (node.id == EGO_CURRENT) {
      d3.select("#eg_reselect").node().disabled = true;
    } else {
      d3.select("#eg_reselect").node().disabled = false;
    }
    d3.select("#eg_next")
      .text(node.id)
      .style(
        "color",
        node.id == EGO_CURRENT ? "gray" : color_for_group(node.group)
      );
  } else {
    node.__selected__ = false;
    SELECTED_NODES.delete(node.id);
    remove_array_item(SELECTION_ORDER, node.id);
    if (NODES) {
      NODES.classed("selected", d => SELECTED_NODES.has(d.id));
    }
    if (EGO_NODES) {
      EGO_NODES.classed("selected", d => SELECTED_NODES.has(d.id));
    }
    if (AFFINITY_NODES) {
      AFFINITY_NODES.classed("selected", d => SELECTED_NODES.has(d.id));
    }
    if (LISTINGS) {
      LISTINGS.classed("selected", d => SELECTED_NODES.has(d.id));
    }
    if (LINKS) {
      if (SELECTED_NODES.size == 0) {
        LINKS.style(
          "visibility",
          d => SHOW_LINKS[link_class(d)] ? "visible" : "hidden"
        );
      } else {
        LINKS.style(
          "visibility",
          d => (
            SELECTED_NODES.has(d.source.id)
         || SELECTED_NODES.has(d.target.id)
          ) ? "visible" : "hidden"
        );
      }
    }
    if (
      SELECTED_NODES.size == 0
    ) {
      d3.select("#eg_reselect").node().disabled = true;
      d3.select("#eg_next")
        .text("")
        .style("color", "gray");
    } else if (
      SELECTED_NODES.size == 1 && SELECTED_NODES.has(EGO_CURRENT)
    ) {
      d3.select("#eg_reselect").node().disabled = true;
      d3.select("#eg_next")
        .text(EGO_CURRENT)
        .style("color", "gray");
    } else {
      d3.select("#eg_reselect").node().disabled = false;
      let sel_id = SELECTION_ORDER[SELECTION_ORDER.length-1];
      let sel_node = lookup_node(sel_id);
      d3.select("#eg_next")
        .text(sel_id)
        .style("color", color_for_group(sel_node.group));
    }
  }
  let sel = {};
  for (let prp of Object.keys(HIST_COLORS)) {
    sel[prp] = new Set();
  };
  let sel_data = GRAPH.nodes.filter(d => SELECTED_NODES.has(d.id));
  for (let d of sel_data) {
    for (let prp of Object.keys(HIST_COLORS)) {
      sel[prp].add(d[prp]);
    };
  }
  if (BARS_GROUP) {
    for (let prp of Object.keys(HIST_COLORS)) {
      BARS_GROUP.selectAll("rect.bar." + prp)
        .classed("selected", d => sel[prp].has(d[0]));
    }
  }
  set_link_visibility();
  update_node_diffs();
}

function set_difference(a, b) {
  return new Set([...a].filter(x => !b.has(x)));
}

function set_intersection(a, b) {
  return new Set([...a].filter(x => b.has(x)));
}

function update_node_diffs() {
  let ob_plus = document.getElementById("add_outside_nodes");
  let ob_minus = document.getElementById("remove_outside_nodes");
  let ib_plus = document.getElementById("add_inside_nodes");
  let ib_minus = document.getElementById("remove_inside_nodes");

  if (GRAPH.__aff_outside__ == undefined || GRAPH.__aff_inside__ == undefined) {
    ob_plus.value = '~';
    ob_plus.disabled = true;
    ob_minus.value = '~';
    ob_minus.disabled = true;
    ib_plus.value = '~';
    ib_plus.disabled = true;
    ib_minus.value = '~';
    ib_minus.disabled = true;
    return;
  }

  let out_set = new Set(GRAPH.__aff_outside__);
  let in_set = new Set(GRAPH.__aff_inside__);

  let out_additions = set_difference(
    set_difference(SELECTED_NODES, in_set),
    out_set
  );
  let out_removals = set_intersection(out_set, SELECTED_NODES);
  let in_additions = set_difference(
    set_difference(SELECTED_NODES, out_set),
    in_set
  );
  let in_removals = set_intersection(in_set, SELECTED_NODES);

  if (out_additions.size == 0) {
    ob_plus.value = '~';
    ob_plus.disabled = true;
  } else {
    ob_plus.value = '+' + out_additions.size;
    ob_plus.disabled = false;
  }

  if (out_removals.size == 0) {
    ob_minus.value = '~';
    ob_minus.disabled = true;
  } else if (out_set.size - out_removals.size < 2) {
    ob_minus.value = '!';
    ob_minus.disabled = true;
  } else {
    ob_minus.value = "-" + out_removals.size;
    ob_minus.disabled = false;
  }

  if (in_additions.size == 0) {
    ib_plus.value = '~';
    ib_plus.disabled = true;
  } else {
    ib_plus.value = '+' + in_additions.size;
    ib_plus.disabled = false;
  }

  if (in_removals.size == 0) {
    ib_minus.value = '~';
    ib_minus.disabled = true;
  } else {
    ib_minus.value = "-" + in_removals.size;
    ib_minus.disabled = false;
  }
}

function toggle_legend_names(on) {
  COMPLETE_LEGEND = on;
  NODES.selectAll(".legend_label")
    .style("visibility", on ? "visible" : "hidden");
}

function toggle_link_visibility(cls, on) {
  SHOW_LINKS[cls] = on;
  LINKS_GROUP.selectAll("." + cls)
    .style("visibility", on ? "visible" : "hidden");
}

function copy_raw_node(node) {
  // Copies just the core properties
  return {
    "id": node.id,
    "initiated": node.initiated,
    "received": node.received,
    "group": node.group,
  }
}

function copy_raw_link(link) {
  // Copies just the core properties (pre-augmentation)
  return {
    "source": link.source,
    "target": link.target,
    "value": link.value
  }
}

function filter_raw_graph(graph) {
  // Produces a graph that only contains nodes whose groups are tagged as core.
  // unaugmented graph as the argument.
  let result = {
    "nodes": [],
    "links": [],
    "dlinks": [],
    "groups": [...graph.groups]
  }
  let allowed = new Set();
  for (let group of result.groups) {
    if (group.tags.includes("core")) {
      allowed.add(group.id);
    }
  }
  let pass = new Set();
  for (let node of graph.nodes) {
    if (allowed.has(node.group)) {
      result.nodes.push(copy_raw_node(node));
      pass.add(node.id);
    }
  }
  for (let link of graph.links) {
    if (pass.has(link.source) && pass.has(link.target)) {
      result.links.push(copy_raw_link(link));
    }
  }

  for (let link of graph.dlinks) {
    if (pass.has(link.source) && pass.has(link.target)) {
      result.dlinks.push(copy_raw_link(link));
    }
  }

  augment_graph(result);

  return result;
}

function toggle_node_filter(on) {
  if (!ORIGINAL) {
    return;
  }
  if (on) {
    GRAPH = FILTERED;
  } else {
    GRAPH = ORIGINAL;
  }
  select_graph(document.getElementById("graph_select").value);

  let n = SIMULATION.nodes().length;
  let bespan = document.getElementById("best_energy");
  if (bespan != null) {
    if (BEST_ENERGIES[n] == undefined) {
      bespan.innerHTML = "?";
    } else {
      bespan.innerHTML = BEST_ENERGIES[n].toExponential(3);
    }
  }
}

function toggle_node_transparency(on) {
  NODE_TRANSPARENCY = on;
  // Update graph nodes:
  let node_groups = d3.selectAll(".nodes")
  node_groups.selectAll(".symbol")
    .attr("fill", d => color_for_group(d.group));
  // Update legend entirely:
  set_legend(GRAPH_TYPE);
}

COLLAPSE_HISTOGRAMS = true;

function toggle_hist_collapse(on) {
  COLLAPSE_HISTOGRAMS = on;
  set_bars(GRAPH.nodes);
}

function update_listings(sort_by) {
  if (sort_by == undefined) {
    sort_by = document.getElementById("listing_sort").value;
  }
  let nodes = LISTING.selectAll("div").data();
  let sorted_nodes = [...nodes].sort(
    function(a, b) {
      if (sort_by == "default") {
        if (GRAPH_TYPE == "force") {
          // sort by hive order if present otherwise by x/y dist from center
          if (a.__hive_rank__ != undefined) {
            return (
              d3.ascending(a.__hive_rank__, b.__hive_rank__)
           || d3.descending(a.initiated + a.received, b.initiated + b.received)
           || d3.descending(a.initiated, b.initiated)
           || d3.ascending(a.id, b.id)
            );
          } else {
            let avx = a.x - LARGE_GRAPH_WIDTH/2;
            let avy = a.y - LARGE_GRAPH_WIDTH/2;
            let ad = Math.sqrt(avx*avx + avy*avy);
            let bvx = b.x - LARGE_GRAPH_WIDTH/2;
            let bvy = b.y - LARGE_GRAPH_WIDTH/2;
            let bd = Math.sqrt(bvx*bvx + bvy*bvy);
            return (
              d3.ascending(ad, bd)
           || d3.descending(a.initiated + a.received, b.initiated + b.received)
           || d3.ascending(a.id, b.id)
            );
          }
        } else if (GRAPH_TYPE == "histogram") { // sort by initiated
          let subtype = document.getElementById("which_histogram").value;
          if (subtype == "initiated") {
            return (
              d3.descending(a.initiated, b.initiated)
           || d3.descending(a.received, b.received)
           || d3.ascending(a.id, b.id)
            );
          } else if (subtype == "received") { // sort by received
            return (
              d3.descending(a.received, b.received)
           || d3.descending(a.initiated, b.initiated)
           || d3.ascending(a.id, b.id)
            );
          } else if (subtype == "interactions") { // sort by combined
            return (
              d3.descending(a.interactions, b.interactions)
           || d3.descending(a.initiated, b.initiated)
           || d3.ascending(a.id, b.id)
            );
          } else if (subtype == "neighbors") { // sort by neighbors
            return (
              d3.descending(a.neighbors, b.neighbors)
           || d3.descending(a.initiated, b.initiated)
           || d3.descending(a.initiated + a.received, b.initiated + b.received)
           || d3.ascending(a.id, b.id)
            );
          } else {
            // Default for histograms: sort by interactions (shouldn't happen)
            return (
              d3.descending(a.interactions, b.interactions)
           || d3.descending(a.initiated, b.initiated)
           || d3.ascending(a.id, b.id)
            );
          }
        } else if (GRAPH_TYPE == "ego") { // sort by current ego order
          if (a.__ego_rank__ != undefined && b.__ego_rank__ != undefined) {
            return d3.ascending(a.__ego_rank__.rank, b.__ego_rank__.rank);
          } else {
            // TODO: Simpler fallback here?
            let a_flink = lookup_dlink(a.id, EGO_CURRENT);
            let b_flink = lookup_dlink(b.id, EGO_CURRENT);
            let a_rlink = lookup_dlink(EGO_CURRENT, a.id);
            let b_rlink = lookup_dlink(EGO_CURRENT, b.id);
            let a_fval = a_flink != undefined ? a_flink.value : 0;
            let b_fval = b_flink != undefined ? b_flink.value : 0;
            let a_rval = a_rlink != undefined ? a_rlink.value : 0;
            let b_rval = b_rlink != undefined ? b_rlink.value : 0;
            return (
              d3.descending(+(a.id == EGO_CURRENT), +(b.id == EGO_CURRENT))
           || d3.descending(a_fval + a_rval, b_fval + b_rval)
           || d3.descending(
                (a_fval > 0) + (a_rval > 0),
                (b_fval > 0) + (b_rval > 0)
              )
           || d3.descending(a_rval, b_rval)
           || d3.descending(group_index(a.group), group_index(b.group))
           || d3.ascending(a.id, b.id)
            );
          }
        } else if (GRAPH_TYPE == "affinity") { // sort by outside -> inside
          if (GRAPH.__aff_outside__ != undefined) {
            let oset = new Set(GRAPH.__aff_outside__);
            let iset = new Set(GRAPH.__aff_inside__);
            let a_oconn = 0;
            let b_oconn = 0;
            for (let link of GRAPH.links) {
              if (link.source.id == a.id) {
                if (oset.has(link.target.id)) {
                  a_oconn += link.value;
                }
              } else if (link.target.id == a.id) {
                if (oset.has(link.source.id)) {
                  a_oconn += link.value;
                }
              }
              if (link.source.id == b.id) {
                if (oset.has(link.target.id)) {
                  b_oconn += link.value;
                }
              } else if (link.target.id == b.id) {
                if (oset.has(link.source.id)) {
                  b_oconn += link.value;
                }
              }
            }
            return (
              d3.descending(oset.has(a.id), oset.has(b.id)) // outside first
           || d3.descending(iset.has(a.id), iset.has(b.id)) // then inside
           || d3.descending(a_oconn, b_oconn) // then connections to outside
           || d3.descending(a.interactions, b.interactions) // then total
           || d3.descending(group_index(a.group), group_index(b.group)) // group
           || d3.ascending(a.id, b.id) // then by ID
            );
          } else { // shouldn't happen; sort by total
            return (
              d3.descending(a.initiated + a.received, b.initiated + b.received)
           || d3.descending(a.initiated, b.initiated)
           || d3.descending(group_index(a.group), group_index(b.group))
           || d3.ascending(a.id, b.id)
            );
          }
        } else { // default to sort-by-total
          return (
            d3.descending(a.initiated + a.received, b.initiated + b.received)
         || d3.descending(a.initiated, b.initiated)
         || d3.descending(group_index(a.group), group_index(b.group))
         || d3.ascending(a.id, b.id)
          );
        }
      } else if (sort_by == "group") {
        return (
          d3.descending(group_index(a.group), group_index(b.group))
       || d3.ascending(a.id, b.id)
        );
      } else if (sort_by == "name") {
        return (
          d3.ascending(a.id, b.id)
       || d3.descending(group_index(a.group), group_index(b.group))
       || d3.descending(a.initiated + a.received, b.initiated + b.received)
        );
      } else if (sort_by == "initiated") {
        if (GRAPH_TYPE == "ego") {
          let a_flink = lookup_dlink(a.id, EGO_CURRENT);
          let b_flink = lookup_dlink(b.id, EGO_CURRENT);
          let a_rlink = lookup_dlink(EGO_CURRENT, a.id);
          let b_rlink = lookup_dlink(EGO_CURRENT, b.id);
          let a_fval = a_flink != undefined ? a_flink.value : 0;
          let b_fval = b_flink != undefined ? b_flink.value : 0;
          let a_rval = a_rlink != undefined ? a_rlink.value : 0;
          let b_rval = b_rlink != undefined ? b_rlink.value : 0;
          return (
            d3.descending(+(a.id == EGO_CURRENT), +(b.id == EGO_CURRENT))
         || d3.descending(a_fval, b_fval)
         || d3.descending(a_rval, b_rval)
         || d3.descending(group_index(a.group), group_index(b.group))
         || d3.ascending(a.id, b.id)
          );
        } else {
          return (
            d3.descending(a.initiated, b.initiated)
         || d3.descending(a.received, b.received)
         || d3.descending(group_index(a.group), group_index(b.group))
         || d3.ascending(a.id, b.id)
          );
        }
      } else if (sort_by == "received") {
        if (GRAPH_TYPE == "ego") {
          let a_flink = lookup_dlink(a.id, EGO_CURRENT);
          let b_flink = lookup_dlink(b.id, EGO_CURRENT);
          let a_rlink = lookup_dlink(EGO_CURRENT, a.id);
          let b_rlink = lookup_dlink(EGO_CURRENT, b.id);
          let a_fval = a_flink != undefined ? a_flink.value : 0;
          let b_fval = b_flink != undefined ? b_flink.value : 0;
          let a_rval = a_rlink != undefined ? a_rlink.value : 0;
          let b_rval = b_rlink != undefined ? b_rlink.value : 0;
          return (
            d3.descending(+(a.id == EGO_CURRENT), +(b.id == EGO_CURRENT))
         || d3.descending(a_rval, b_rval)
         || d3.descending(a_fval, b_fval)
         || d3.descending(group_index(a.group), group_index(b.group))
         || d3.ascending(a.id, b.id)
          );
        } else {
          return (
            d3.descending(a.received, b.received)
         || d3.descending(a.initiated, b.initiated)
         || d3.descending(group_index(a.group), group_index(b.group))
         || d3.ascending(a.id, b.id)
          );
        }
      } else if (sort_by == "total") {
        if (GRAPH_TYPE == "ego") {
          let a_flink = lookup_dlink(a.id, EGO_CURRENT);
          let b_flink = lookup_dlink(b.id, EGO_CURRENT);
          let a_rlink = lookup_dlink(EGO_CURRENT, a.id);
          let b_rlink = lookup_dlink(EGO_CURRENT, b.id);
          let a_fval = a_flink != undefined ? a_flink.value : 0;
          let b_fval = b_flink != undefined ? b_flink.value : 0;
          let a_rval = a_rlink != undefined ? a_rlink.value : 0;
          let b_rval = b_rlink != undefined ? b_rlink.value : 0;
          return (
            d3.descending(+(a.id == EGO_CURRENT), +(b.id == EGO_CURRENT))
         || d3.descending(a_fval + a_rval, b_fval + b_rval)
         || d3.descending(a_fval, b_fval)
         || d3.descending(group_index(a.group), group_index(b.group))
         || d3.ascending(a.id, b.id)
          );
        } else {
          return (
            d3.descending(a.initiated + a.received, b.initiated + b.received)
         || d3.descending(a.initiated, b.initiated)
         || d3.descending(group_index(a.group), group_index(b.group))
         || d3.ascending(a.id, b.id)
          );
        }
      } else if (sort_by == "neighbors") {
        return (
          d3.descending(a.neighbors, b.neighbors)
       || d3.descending(a.initiated, b.initiated)
       || d3.descending(a.initiated + a.received, b.initiated + b.received)
       || d3.descending(group_index(a.group), group_index(b.group))
       || d3.ascending(a.id, b.id)
        );
      } else {
        console.warn("Invalid sort scheme: '" + sort_by + "'; defaulting.")
        return (
          d3.ascending(a.id, b.id)
       || d3.descending(group_index(a.group), group_index(b.group))
       || d3.descending(a.initiated + a.received, b.initiated + b.received)
        );
      }
    }
  );
  LISTING.selectAll("div").remove();
  LISTINGS = LISTING.selectAll("div")
    .data(sorted_nodes)
    .enter().append("div")

  LISTINGS
    .classed("listing", true)
    .classed("selected", d => SELECTED_NODES.has(d.id));

  var char_identities = LISTINGS.append("span")
    .classed("identity", true)
    .text(function (d) { return identity_for(d); });
  var char_labels = LISTINGS.append("a")
    .text(function (d) { return d.id; })
    .attr("href", "#")
    .style("color", function(d) { return solid_color_for_group(d.group); })
    // Note: color here ignores transparency
    .on("click", d => toggle_select(d, !d.__selected__));

  // Add stats to listings:
  var lst_initiated = d => d.initiated;
  var lst_received = d => d.received;
  var lst_total = d => d.initiated + d.received;
  var lst_neighbors = d => d.neighbors;

  if (GRAPH_TYPE == "ego") {
    lst_initiated = function(d) {
      if (d.id == EGO_CURRENT) { return d.initiated; }
      let flink = lookup_dlink(d.id, EGO_CURRENT);
      return flink != undefined ? flink.value : 0;
    }
    lst_received = function(d) {
      if (d.id == EGO_CURRENT) { return d.received; }
      let rlink = lookup_dlink(EGO_CURRENT, d.id);
      return rlink != undefined ? rlink.value : 0;
    }
    lst_total = function(d) {
      return lst_initiated(d) + lst_received(d);
    }
    // neighbors is unchanged
  }

  LISTINGS.append("span")
    .classed("stats", true)
    .text(function(d) { return "🗣" + lst_initiated(d); })

  LISTINGS.append("span")
    .classed("stats", true)
    .text(function(d) { return "👂" + lst_received(d); })

  LISTINGS.append("span")
    .classed("stats", true)
    .text(function(d) { return "=" + lst_total(d); });

  LISTINGS.append("span")
    .classed("stats", true)
    .text(function(d) { return "⇔" + lst_neighbors(d); });
}

function filter_listings(string) {
  LISTINGS.style("display", function (d) {
    if (d.id.toLowerCase().includes(string.toLowerCase())) {
      return "grid";
    } else {
      return "none";
    }
  });
}

function set_node_size(val) {
  NODE_RADIUS = val;
  let node_groups = d3.selectAll(".nodes")
  node_groups.selectAll(".symbol")
    .attr("d", d => symbol_path_data([0, 0], val, shape_for_group(d.group)))
    .style("stroke-width", Math.min(1.5, 1.5*(NODE_RADIUS/BASE_RADIUS)) + "pt");
  node_groups.selectAll("text.identity").style(
    "font-size", d => font_size_for_identity(d)
  );
}

function setup_help(help_html) {
  // Set up help links to show help:
  d3.selectAll("a.help")
    .on(
      "click",
      function () {
        d3.select("#help").style("visibility", "visible");
      }
    );
  d3.select("#unhelp")
    .on(
      "click",
      function () {
        d3.select("#help").style("visibility", "hidden");
      }
    );

  // Pipe in help content
  d3.select("#help_content").html(help_html);

  // Set up click handler on help itself so that if you hit the shaded area it
  // also closes the help.
  d3.select("#help")
    .on(
      "click",
      function() {
        if (d3.event.target.getAttribute("id") == "help") {
          d3.select("#help").style("visibility", "hidden");
        }
      }
    )
}

// Set up pattern defs in SVG elements
function make_pattern(pattern, type, stripe_color, background_color) {
  // Takes an empty 10x10 d3 pattern and appends elements to make a pattern.
  // The type must be one of:
  //   "horizontal": horizontal stripes
  //   "vertical": vertical stripes
  //   "squares": squares
  //   "circles": circles
  let stroke_width = 1;
  if (background_color) {
    // TODO: White background when there's no color specified?
    pattern
      .append("rect")
      .attr('width', 10)
      .attr('height', 10)
      .attr('x', 0)
      .attr('y', 0)
      .attr('fill', background_color)
  }
  if (type == "horizontal") {
    pattern.append("rect")
      .attr('x', 0)
      .attr('y', 0)
      .attr('width', 10)
      .attr('height', stroke_width)
      .attr('fill', stripe_color)
  } else if (type == "vertical") {
    pattern.append("rect")
      .attr('x', 0)
      .attr('y', 0)
      .attr('width', stroke_width)
      .attr('height', 10)
      .attr('fill', stripe_color)
  } else if (type == "fwd_diag") {
    pattern.append("path")
      .attr(
          'd',
          'M-1,3 l3,-3 '
        + 'M-1,8 l8,-8 '
        + 'M1,11 l9,-9 '
        + 'M6,11 l4,-4'
      )
      .attr('stroke', stripe_color)
      .attr('stroke-width', stroke_width)
  } else if (type == "back_diag") {
    pattern.append("path")
      .attr(
          'd',
          'M11,3 l-3,-3 '
        + 'M11,8 l-8,-8 '
        + 'M9,11 l-9,-9 '
        + 'M4,11 l-4,-4'
      )
      .attr('stroke', stripe_color)
      .attr('stroke-width', stroke_width)
  } else if (type == "cross") {
    pattern.append("path")
      .attr(
          'd',
          'M-1,3 l3,-3 '
        + 'M-1,8 l8,-8 '
        + 'M1,11 l9,-9 '
        + 'M6,11 l4,-4'
      )
      .attr('stroke', stripe_color)
      .attr('stroke-width', stroke_width)
    pattern.append("path")
      .attr(
          'd',
          'M11,3 l-3,-3 '
        + 'M11,8 l-8,-8 '
        + 'M9,11 l-9,-9 '
        + 'M4,11 l-4,-4'
      )
      .attr('stroke', stripe_color)
      .attr('stroke-width', stroke_width)
  } else if (type == "waves") {
    pattern.append("path")
      .attr(
          'd',
          'M0,3 q2.5,2.5,5,0 t5,0'
        + 'M0,8 q2.5,2.5,5,0 t5,0'
      )
      .attr('stroke', stripe_color)
      .attr('stroke-width', stroke_width)
      .attr('fill-opacity', 0)
  } else if (type == "squares") {
    pattern.append("rect")
      .attr('x', 0)
      .attr('y', 0)
      .attr('width', 5)
      .attr('height', 5)
      .attr('stroke', stripe_color)
      .attr('stroke-width', stroke_width)
      .attr('fill', "none")
  } else if (type == "circles") {
    pattern.append("circle")
      .attr('cx', 3.5)
      .attr('cy', 3.5)
      .attr('r', 3.5)
      .attr('stroke', stripe_color)
      .attr('stroke-width', stroke_width)
      .attr('fill', "none")
  } else {
    console.log("Unknown pattern type: '" + type + "'");
  }
}

function add_pattern_defs(svg) {
  /*
   * Adds pattern definitions to the given SVG.
   * Base patterns from:
   *   http://iros.github.io/patternfills/
   * Background idea from:
   *   https://stackoverflow.com/questions/37429608/can-i-have-a-svg-pattern-with-background-color
   */

  let defs = svg.append("defs")

  for (let key of Object.keys(HIST_COLORS)) {
    let color = HIST_COLORS[key];
    let bg = HIST_BG_COLORS[key];
    let type = HIST_SHADING[key];
    let pattern = defs
      .append("pattern")
      .attr("id", key + "-pattern")
      .attr("patternUnits", "userSpaceOnUse")
      .attr("width", 10)
      .attr("height", 10)
    make_pattern(pattern, type, color, bg);
  }
}

function symbol_path_data(where, radius, shape) {
  let path = undefined;
  if (shape == "star_five") {
    let bigR = radius*1.5;
    let smallR = radius*0.9;
    let angle_share = (2*Math.PI)/5.0;
    path = "M" + where[0] + "," + (where[1] - bigR)
    for (let point of [0, 1, 2, 3, 4]) {
      let angle = 3*Math.PI/2 - ((point+1) * angle_share);
      let half_angle = 3*Math.PI/2 - ((point+0.5) * angle_share);
      let p0 = [
        where[0] + smallR * Math.cos(half_angle),
        where[1] + smallR * Math.sin(half_angle)
      ];
      let p1 = [
        where[0] + bigR * Math.cos(angle),
        where[1] + bigR * Math.sin(angle)
      ];
      path += " L" + p0[0] + "," + p0[1] + " L" + p1[0] + "," + p1[1]
    }

  } else if (shape == "hexagon") {
    let angle = 0;
    let angle_share = Math.PI/3.0;
    let fullR = radius*1.4;
    path = "M" + (where[0] + fullR) + "," + where[1];
    for (let point of [1, 2, 3, 4, 5]) {
      angle += angle_share;
      let p = [
        where[0] + fullR * Math.cos(angle),
        where[1] + fullR * Math.sin(angle)
      ];
      path += " L" + p[0] + "," + p[1];
    }
    path += " Z";

  } else if (shape == "double_trapezoid") {
    let width = radius*2.4;
    let height = radius*2;
    path = "M" + (where[0] + width/2) + "," + (where[1] - height/2);
    path += " L" + (where[0] + radius) + "," + where[1];
    path += " L" + (where[0] + width/2) + "," + (where[1] + height/2);
    path += " L" + (where[0] - width/2) + "," + (where[1] + height/2);
    path += " L" + (where[0] - radius) + "," + where[1];
    path += " L" + (where[0] - width/2) + "," + (where[1] - height/2);
    path += " Z";

  } else if (shape == "star_four") {
    let width = radius*2.6;
    let height = radius*2.6;
    path = "M" + (where[0] + width/2) + "," + (where[1] - height/2);
    path += " L" + (where[0] + radius) + "," + where[1];
    path += " L" + (where[0] + width/2) + "," + (where[1] + height/2);
    path += " L" + where[0] + "," + (where[1] + radius);
    path += " L" + (where[0] - width/2) + "," + (where[1] + height/2);
    path += " L" + (where[0] - radius) + "," + where[1];
    path += " L" + (where[0] - width/2) + "," + (where[1] - height/2);
    path += " L" + where[0] + "," + (where[1] - radius);
    path += " Z";

  } else if (shape == "square") {
    path = "M" + (where[0] + radius) + "," + (where[1] - radius);
    path += " L" + (where[0] + radius) + "," + (where[1] + radius);
    path += " L" + (where[0] - radius) + "," + (where[1] + radius);
    path += " L" + (where[0] - radius) + "," + (where[1] - radius);
    path += " Z";

  } else if (shape == "diamond") {
    let bigR = radius*1.4;
    path = "M" + where[0] + "," + (where[1] - bigR);
    path += " L" + (where[0] + bigR) + "," + where[1];
    path += " L" + where[0] + "," + (where[1] + bigR);
    path += " L" + (where[0] - bigR) + "," + where[1];
    path += " Z";

  } else if (shape == "rounded") {
    let bigR = radius*1.2;
    path = "M" + where[0] + "," + (where[1] - bigR);
    path += " q " + bigR + "," + 0 + "," + bigR + "," + bigR
    path += " t" + (-bigR) + "," + bigR
    path += " t" + (-bigR) + "," + (-bigR)
    path += " t" + bigR + "," + (-bigR)

  } else {
    console.error("Unknown shape: '" + shape + "'");
  }
  return path;
}

// Actually attach pattern definitions to each SVG:
d3.selectAll("svg.graph")
  .each(
      function () {
        add_pattern_defs(d3.select(this))
      }
  )

// In-line help HTML
inline_help = undefined;
if (inline_help != undefined) {
  setup_help(inline_help);
} else {
  let help_file = "help.html"; // the default
  let url = new URL(window.location.href);
  let target = url.searchParams.get("h");
  if (target) {
    help_file = target;
  }
  d3.text(
    help_file,
    function(error, html) {
      if (error) { throw error; }
      setup_help(html);
    }
  );
}

// In-line graph data
inline_data = undefined;

// Finally, load the data file or use the in-line data:
if (inline_data != undefined) {
  receive_data(inline_data);
} else {
  let data_file = "data/example-graph.json"; // the default
  let url = new URL(window.location.href);
  let target = url.searchParams.get("t");
  if (target) {
    data_file = target;
  }
  d3.json(
    data_file,
    function(error, graph) {
      if (error) { throw error; }
      receive_data(graph)
    }
  );
}

    </script>
  </body>
</html>
